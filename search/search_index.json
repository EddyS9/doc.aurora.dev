{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Project Aurora \u00b6 Here be dragons This documentation is a work in progress and may contain incomplete, inaccurate, or outdated information. Aurora is an Ethereum Virtual Machine (EVM) on the NEAR Protocol blockchain, delivering a turn-key solution for developers to operate their apps on an Ethereum-compatible, high-throughput, scalable, and future-safe platform, with low transaction costs for their users. Aurora provides the Ethereum 1.0 development experience, with layer-2-like speed and scalability. If you are an Ethereum developer, getting starting on Aurora is as easy as changing the RPC endpoint you interact with. If you're ready to dive in check out our Develop page for more information. The capabilities of Aurora are possible because it is built on top of NEAR . NEAR is a modern layer-1 blockchain which is fast (2-3 second transaction finalization), scalable, and carbon neutral . Even though NEAR is a separate blockchain from Ethereum, Aurora aims for full compatibility with Ethereum development tools such as Truffle and Hardhat . Additionally, NEAR's trustless bridge to Ethereum means even the assets on Aurora are the same as Ethereum. For example, account balances in Aurora's EVM are denominated in the same Ether (ETH) as on Ethereum itself. Still have questions? Check out our answers to frequently asked questions (FAQs) .","title":"Overview"},{"location":"index.html#welcome-to-project-aurora","text":"Here be dragons This documentation is a work in progress and may contain incomplete, inaccurate, or outdated information. Aurora is an Ethereum Virtual Machine (EVM) on the NEAR Protocol blockchain, delivering a turn-key solution for developers to operate their apps on an Ethereum-compatible, high-throughput, scalable, and future-safe platform, with low transaction costs for their users. Aurora provides the Ethereum 1.0 development experience, with layer-2-like speed and scalability. If you are an Ethereum developer, getting starting on Aurora is as easy as changing the RPC endpoint you interact with. If you're ready to dive in check out our Develop page for more information. The capabilities of Aurora are possible because it is built on top of NEAR . NEAR is a modern layer-1 blockchain which is fast (2-3 second transaction finalization), scalable, and carbon neutral . Even though NEAR is a separate blockchain from Ethereum, Aurora aims for full compatibility with Ethereum development tools such as Truffle and Hardhat . Additionally, NEAR's trustless bridge to Ethereum means even the assets on Aurora are the same as Ethereum. For example, account balances in Aurora's EVM are denominated in the same Ether (ETH) as on Ethereum itself. Still have questions? Check out our answers to frequently asked questions (FAQs) .","title":"Welcome to Project Aurora"},{"location":"media.html","text":"Media Kit \u00b6","title":"Aurora: Media Kit"},{"location":"media.html#media-kit","text":"","title":"Media Kit"},{"location":"develop/index.html","text":"","title":"Index"},{"location":"develop/changelog.html","text":"Changelog \u00b6 2021-05-24 \u00b6 All endpoints \u00b6 Aurora Relayer: Fixed a bug in the eth_call RPC method. This had been affecting MetaMask users in particular. ( 1d0d7cd ) 2021-05-19 \u00b6 We have rolled out new endpoint URLs . Changing from the former endpoint URL https://rpc.$NETWORK.aurora.dev:8545 to https://$NETWORK.aurora.dev is recommended and will decrease your response latency and increase your rate limits. 2021-05-17 \u00b6 All endpoints \u00b6 Aurora Relayer: Fixed a response encoding discrepancy with the eth_getTransactionReceipt RPC method which was causing Truffle to believe that the transaction reverted when deploying contracts. ( 2500fd9 ) 2021-05-13 \u00b6 All endpoints \u00b6 Aurora Relayer: Fixed a regression in the eth_getTransactionReceipt RPC method. ( 07dc0da ) Fixed the CORS preflight response by ensuring that the response has status code 204 and contains the Access-Control-Allow-Origin: * and Access-Control-Allow-Methods: OPTIONS, POST headers. 2021-05-12 \u00b6 Launched Aurora publicly . All networks \u00b6 Aurora Engine: Deployed release 1.0.0 to MainNet, TestNet, and BetaNet.","title":"Changelog"},{"location":"develop/changelog.html#changelog","text":"","title":"Changelog"},{"location":"develop/changelog.html#2021-05-24","text":"","title":"2021-05-24"},{"location":"develop/changelog.html#all-endpoints","text":"Aurora Relayer: Fixed a bug in the eth_call RPC method. This had been affecting MetaMask users in particular. ( 1d0d7cd )","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-19","text":"We have rolled out new endpoint URLs . Changing from the former endpoint URL https://rpc.$NETWORK.aurora.dev:8545 to https://$NETWORK.aurora.dev is recommended and will decrease your response latency and increase your rate limits.","title":"2021-05-19"},{"location":"develop/changelog.html#2021-05-17","text":"","title":"2021-05-17"},{"location":"develop/changelog.html#all-endpoints_1","text":"Aurora Relayer: Fixed a response encoding discrepancy with the eth_getTransactionReceipt RPC method which was causing Truffle to believe that the transaction reverted when deploying contracts. ( 2500fd9 )","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-13","text":"","title":"2021-05-13"},{"location":"develop/changelog.html#all-endpoints_2","text":"Aurora Relayer: Fixed a regression in the eth_getTransactionReceipt RPC method. ( 07dc0da ) Fixed the CORS preflight response by ensuring that the response has status code 204 and contains the Access-Control-Allow-Origin: * and Access-Control-Allow-Methods: OPTIONS, POST headers.","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-12","text":"Launched Aurora publicly .","title":"2021-05-12"},{"location":"develop/changelog.html#all-networks","text":"Aurora Engine: Deployed release 1.0.0 to MainNet, TestNet, and BetaNet.","title":"All networks"},{"location":"develop/faq.html","text":"Frequently Asked Questions \u00b6 I'm an app developer. Why should I choose Aurora over other EVMs? \u00b6 Aurora was built by the same team that created the NEAR Protocol, considered to be among the most highly regarded blockchain technologies in the crypto space. Although created at NEAR, Aurora will be exist as a separate entity, governed by the decentralized AuroraDAO, and will leverage the unique underlying NEAR technologies to align incentives of the network, product owners, and end users. When you choose to deploy your app on Aurora, you\u2019re partnering with a highly-capable and dedicated organization, and building upon a technical foundation that will scale to meet all your future needs. What are the basic performance metrics? \u00b6 Aurora is a major use case for the NEAR blockchain that requires many changes on different levels. At the moment we\u2019re waiting for NEAR validators to accept the protocol change that will add EVM precompiles. We expect this to happen in the first half of the summer. After this protocol upgrade one can expect Aurora to be able to host twice the throughput of the Ethereum mainnet. There\u2019s still a lot of room for a single-shard Aurora improvement, so we expect further throughput increases. How will transaction fees work? \u00b6 The base fee token of Aurora is ETH, which will make your users feel right at home. By leveraging the underlying low-cost capabilities of the NEAR Protocol, Aurora transactions will typically cost pennies. What\u2019s particularly interesting, is that the underlying fee model of NEAR opens the door to innovative possibilities, such as AuroraDAO directed mechanisms of channeling a portion of collected fees back to the projects running on Aurora! What does the high-level roadmap look like? \u00b6 While the detailed Aurora roadmap is available on the web site , in general, over the course of summer we plan to optimise Aurora and take care of the DAO formation and token development (if this is decided by the DAO). In Autumn, we plan to deliver several major features, such as introduction of fast bridging of the most popular tokens, ability to pay fees in stable coins and simplified UX for non-blockchain users. We\u2019re planning to deliver a sharded version of Aurora early next year. How do I get started with Aurora? \u00b6 The Aurora EVM has been deployed on the NEAR Mainnet and Testnet networks. Asset connectors\u2014e.g. our \u201cETH Connector\u201d and \u201cERC-20 Connectors\u201d\u2014allow asset transfers between Aurora and Ethereum, using the Aurora Bridge. Currently, the ETH Connector is deployed and functional on Testnet, with the ERC-20 Connector soon to follow. In this way, project owners should be able to test their deployments on Aurora fully in May, followed by production deployments in June of 2021. For those interested in getting started, a set of Aurora Documents is currently available. How will bridging tokens between Ethereum and Aurora work? \u00b6 Very easy! You'll select the direction of transfer, the token you want to transfer, and the amount. Your address on Aurora will be the same as your Ethereum address. The Aurora Bridge will initially work with MetaMask. To access your tokens and apps on Aurora, you\u2019ll need to add Aurora as an additional network to MetaMask, and the Bridge will help you with that. Which tokens will be supported? \u00b6 Initially, ETH\u2014the base fee token of Aurora\u2014will be supported, followed by a select list of popular ERC-20 tokens, and then any arbitrary assets. This rollout is planned to take place during May and June of 2021. How long will transfers take? \u00b6 To ensure security, transfers to Aurora take about 10 minutes, and transfers back to Ethereum take about a day. As you can see from our roadmap, we\u2019ll be dramatically improving those transfer times by Autumn of 2021. Why will transfers take so long? \u00b6 The Aurora Bridge technical architecture is designed to be \u201ctrustless\u201d, meaning there\u2019s no reliance on third-parties for authorizations. Trustless transfers align with the ethos of decentralized finance, but do require more time, given that network confirmations to ensure transaction finality. There are, however, technical ways in which we can, and will, shorten transfer times in future updates to the bridge. Will I be able to initiate multiple transfers in parallel? \u00b6 Yes! Since confirmation of transfer can take a while, you\u2019ll be able to initiate any number of concurrent transfers. I have a few more questions. Where can I get help? \u00b6 For support and help with any questions, don't hesitate to reach out on Telegram channels: official channel , support channel , development channel .","title":"FAQs"},{"location":"develop/faq.html#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"develop/faq.html#im-an-app-developer-why-should-i-choose-aurora-over-other-evms","text":"Aurora was built by the same team that created the NEAR Protocol, considered to be among the most highly regarded blockchain technologies in the crypto space. Although created at NEAR, Aurora will be exist as a separate entity, governed by the decentralized AuroraDAO, and will leverage the unique underlying NEAR technologies to align incentives of the network, product owners, and end users. When you choose to deploy your app on Aurora, you\u2019re partnering with a highly-capable and dedicated organization, and building upon a technical foundation that will scale to meet all your future needs.","title":"I'm an app developer. Why should I choose Aurora over other EVMs?"},{"location":"develop/faq.html#what-are-the-basic-performance-metrics","text":"Aurora is a major use case for the NEAR blockchain that requires many changes on different levels. At the moment we\u2019re waiting for NEAR validators to accept the protocol change that will add EVM precompiles. We expect this to happen in the first half of the summer. After this protocol upgrade one can expect Aurora to be able to host twice the throughput of the Ethereum mainnet. There\u2019s still a lot of room for a single-shard Aurora improvement, so we expect further throughput increases.","title":"What are the basic performance metrics?"},{"location":"develop/faq.html#how-will-transaction-fees-work","text":"The base fee token of Aurora is ETH, which will make your users feel right at home. By leveraging the underlying low-cost capabilities of the NEAR Protocol, Aurora transactions will typically cost pennies. What\u2019s particularly interesting, is that the underlying fee model of NEAR opens the door to innovative possibilities, such as AuroraDAO directed mechanisms of channeling a portion of collected fees back to the projects running on Aurora!","title":"How will transaction fees work?"},{"location":"develop/faq.html#what-does-the-high-level-roadmap-look-like","text":"While the detailed Aurora roadmap is available on the web site , in general, over the course of summer we plan to optimise Aurora and take care of the DAO formation and token development (if this is decided by the DAO). In Autumn, we plan to deliver several major features, such as introduction of fast bridging of the most popular tokens, ability to pay fees in stable coins and simplified UX for non-blockchain users. We\u2019re planning to deliver a sharded version of Aurora early next year.","title":"What does the high-level roadmap look like?"},{"location":"develop/faq.html#how-do-i-get-started-with-aurora","text":"The Aurora EVM has been deployed on the NEAR Mainnet and Testnet networks. Asset connectors\u2014e.g. our \u201cETH Connector\u201d and \u201cERC-20 Connectors\u201d\u2014allow asset transfers between Aurora and Ethereum, using the Aurora Bridge. Currently, the ETH Connector is deployed and functional on Testnet, with the ERC-20 Connector soon to follow. In this way, project owners should be able to test their deployments on Aurora fully in May, followed by production deployments in June of 2021. For those interested in getting started, a set of Aurora Documents is currently available.","title":"How do I get started with Aurora?"},{"location":"develop/faq.html#how-will-bridging-tokens-between-ethereum-and-aurora-work","text":"Very easy! You'll select the direction of transfer, the token you want to transfer, and the amount. Your address on Aurora will be the same as your Ethereum address. The Aurora Bridge will initially work with MetaMask. To access your tokens and apps on Aurora, you\u2019ll need to add Aurora as an additional network to MetaMask, and the Bridge will help you with that.","title":"How will bridging tokens between Ethereum and Aurora work?"},{"location":"develop/faq.html#which-tokens-will-be-supported","text":"Initially, ETH\u2014the base fee token of Aurora\u2014will be supported, followed by a select list of popular ERC-20 tokens, and then any arbitrary assets. This rollout is planned to take place during May and June of 2021.","title":"Which tokens will be supported?"},{"location":"develop/faq.html#how-long-will-transfers-take","text":"To ensure security, transfers to Aurora take about 10 minutes, and transfers back to Ethereum take about a day. As you can see from our roadmap, we\u2019ll be dramatically improving those transfer times by Autumn of 2021.","title":"How long will transfers take?"},{"location":"develop/faq.html#why-will-transfers-take-so-long","text":"The Aurora Bridge technical architecture is designed to be \u201ctrustless\u201d, meaning there\u2019s no reliance on third-parties for authorizations. Trustless transfers align with the ethos of decentralized finance, but do require more time, given that network confirmations to ensure transaction finality. There are, however, technical ways in which we can, and will, shorten transfer times in future updates to the bridge.","title":"Why will transfers take so long?"},{"location":"develop/faq.html#will-i-be-able-to-initiate-multiple-transfers-in-parallel","text":"Yes! Since confirmation of transfer can take a while, you\u2019ll be able to initiate any number of concurrent transfers.","title":"Will I be able to initiate multiple transfers in parallel?"},{"location":"develop/faq.html#i-have-a-few-more-questions-where-can-i-get-help","text":"For support and help with any questions, don't hesitate to reach out on Telegram channels: official channel , support channel , development channel .","title":"I have a few more questions. Where can I get help?"},{"location":"develop/glossary.html","text":"Glossary \u00b6 0-9 \u00b6 A \u00b6 B \u00b6 C \u00b6 D \u00b6 E \u00b6 F \u00b6 G \u00b6 H \u00b6 I \u00b6 J \u00b6 K \u00b6 L \u00b6 M \u00b6 N \u00b6 O \u00b6 P \u00b6 PoS \u00b6 Proof of stake. PoW \u00b6 Proof of work. Q \u00b6 R \u00b6 S \u00b6 T \u00b6 U \u00b6 V \u00b6 W \u00b6 X \u00b6 Y \u00b6 Z \u00b6","title":"Glossary"},{"location":"develop/glossary.html#glossary","text":"","title":"Glossary"},{"location":"develop/glossary.html#0-9","text":"","title":"0-9"},{"location":"develop/glossary.html#a","text":"","title":"A"},{"location":"develop/glossary.html#b","text":"","title":"B"},{"location":"develop/glossary.html#c","text":"","title":"C"},{"location":"develop/glossary.html#d","text":"","title":"D"},{"location":"develop/glossary.html#e","text":"","title":"E"},{"location":"develop/glossary.html#f","text":"","title":"F"},{"location":"develop/glossary.html#g","text":"","title":"G"},{"location":"develop/glossary.html#h","text":"","title":"H"},{"location":"develop/glossary.html#i","text":"","title":"I"},{"location":"develop/glossary.html#j","text":"","title":"J"},{"location":"develop/glossary.html#k","text":"","title":"K"},{"location":"develop/glossary.html#l","text":"","title":"L"},{"location":"develop/glossary.html#m","text":"","title":"M"},{"location":"develop/glossary.html#n","text":"","title":"N"},{"location":"develop/glossary.html#o","text":"","title":"O"},{"location":"develop/glossary.html#p","text":"","title":"P"},{"location":"develop/glossary.html#pos","text":"Proof of stake.","title":"PoS"},{"location":"develop/glossary.html#pow","text":"Proof of work.","title":"PoW"},{"location":"develop/glossary.html#q","text":"","title":"Q"},{"location":"develop/glossary.html#r","text":"","title":"R"},{"location":"develop/glossary.html#s","text":"","title":"S"},{"location":"develop/glossary.html#t","text":"","title":"T"},{"location":"develop/glossary.html#u","text":"","title":"U"},{"location":"develop/glossary.html#v","text":"","title":"V"},{"location":"develop/glossary.html#w","text":"","title":"W"},{"location":"develop/glossary.html#x","text":"","title":"X"},{"location":"develop/glossary.html#y","text":"","title":"Y"},{"location":"develop/glossary.html#z","text":"","title":"Z"},{"location":"develop/networks.html","text":"Networks \u00b6 Ethereum Virtual Machine (EVM) support is currently available on the following networks: Network Engine ID Chain ID Endpoint URL MainNet aurora 1313161554 (0x4e454152) https://mainnet.aurora.dev TestNet aurora 1313161555 (0x4e454153) https://testnet.aurora.dev BetaNet aurora 1313161556 (0x4e454154) https://betanet.aurora.dev LocalNet aurora.test.near 1313161556 (0x4e454154) http://localhost:8545 Find the status page and public incident log at api.aurora.dev . You can also subscribe to incident notifications there. Endpoints \u00b6 MainNet \u00b6 The MainNet Web3 endpoint is at: https://mainnet.aurora.dev (port 443) TestNet \u00b6 The TestNet Web3 endpoint is at: https://testnet.aurora.dev (port 443) BetaNet \u00b6 The BetaNet Web3 endpoint is at: https://betanet.aurora.dev (port 443)","title":"Networks"},{"location":"develop/networks.html#networks","text":"Ethereum Virtual Machine (EVM) support is currently available on the following networks: Network Engine ID Chain ID Endpoint URL MainNet aurora 1313161554 (0x4e454152) https://mainnet.aurora.dev TestNet aurora 1313161555 (0x4e454153) https://testnet.aurora.dev BetaNet aurora 1313161556 (0x4e454154) https://betanet.aurora.dev LocalNet aurora.test.near 1313161556 (0x4e454154) http://localhost:8545 Find the status page and public incident log at api.aurora.dev . You can also subscribe to incident notifications there.","title":"Networks"},{"location":"develop/networks.html#endpoints","text":"","title":"Endpoints"},{"location":"develop/networks.html#mainnet","text":"The MainNet Web3 endpoint is at: https://mainnet.aurora.dev (port 443)","title":"MainNet"},{"location":"develop/networks.html#testnet","text":"The TestNet Web3 endpoint is at: https://testnet.aurora.dev (port 443)","title":"TestNet"},{"location":"develop/networks.html#betanet","text":"The BetaNet Web3 endpoint is at: https://betanet.aurora.dev (port 443)","title":"BetaNet"},{"location":"develop/roadmap.html","text":"Roadmap \u00b6 For the latest roadmap updates, see our posts in the Aurora forum or the roadmap section on Aurora website . Done \u2014 Deploy Aurora Engine to MainNet, TestNet and BetaNet May 2021 \u2014 Transfer ETH and ERC20 tokens beween Ethereum and Aurora May 2021 \u2014 Transfer the NEAR token between Ethereum and NEAR June 2021 \u2014 Completion of Aurora fund-raising campaign June 2021 \u2014 Filling of all AuroraDAO initial seats Autumn 2021 \u2014 Fast token transfer Autumn 2021 \u2014 Gas fees denominated in ERC-20s Autumn 2021 \u2014 Simplified \u201cHide the Blockchain\u201d UX","title":"Roadmap"},{"location":"develop/roadmap.html#roadmap","text":"For the latest roadmap updates, see our posts in the Aurora forum or the roadmap section on Aurora website . Done \u2014 Deploy Aurora Engine to MainNet, TestNet and BetaNet May 2021 \u2014 Transfer ETH and ERC20 tokens beween Ethereum and Aurora May 2021 \u2014 Transfer the NEAR token between Ethereum and NEAR June 2021 \u2014 Completion of Aurora fund-raising campaign June 2021 \u2014 Filling of all AuroraDAO initial seats Autumn 2021 \u2014 Fast token transfer Autumn 2021 \u2014 Gas fees denominated in ERC-20s Autumn 2021 \u2014 Simplified \u201cHide the Blockchain\u201d UX","title":"Roadmap"},{"location":"develop/compat/index.html","text":"Compatibility \u00b6","title":"Aurora: Compatibility"},{"location":"develop/compat/index.html#compatibility","text":"","title":"Compatibility"},{"location":"develop/compat/evm.html","text":"Compatibility with the Ethereum Virtual Machine (EVM) \u00b6 Precompiles \u00b6 Standard precompiles \u00b6 Address ID Name Spec Status 0x01 ECRecover ECDSA public key recovery Yellow Paper \u2705 0x02 SHA256 SHA-2 256-bit hash function Yellow Paper \u2705 0x03 RIPEMD160 RIPEMD 160-bit hash function Yellow Paper \u2705 0x04 Identity Identity function Yellow Paper \u2705 0x05 ModExp Big integer modular exponentation EIP-198 \u2705 0x06 BN128Add Elliptic curve addition EIP-196 \u2705 0x07 BN128Mul Elliptic curve scalar multiplication EIP-196 \u2705 0x08 BN128Pair Elliptic curve pairing check EIP-197 \u2705 0x09 Blake2F BLAKE2b F compression function EIP-152 \u2705 Opcodes \u00b6 BLOCKHASH \u00b6 This opcode currently does not return a real blockhash. However, it does respect the logic that a non-zero value is returned for the most recent 256 blocks (not including the current block). For all other inputs it returns zero. The non-zero value that is returned is 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff . For example, if the current block height is h , then BLOCKHASH(h) = 0x000... , BLOCKHASH(h - 100) = 0xfff... and BLOCKHASH(h - 257) = 0x000.. . This behavior may change in the future, see nearcore#4256 to track this issue. COINBASE \u00b6 This opcode returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b . DIFFICULTY \u00b6 This opcode always returns zero, since NEAR is not a proof-of-work (PoW) network. GASLIMIT \u00b6 This opcode always returns 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff (2^256-1). Limitations \u00b6 The Berlin hard fork is not yet supported. The EVM currently supports the feature set of the Istanbul hard fork. The BLOCKHASH opcode currently always returns either 0xfff... (if the input is within 256 blocks) or 0x000... (for the current height or one more than 256 blocks in the past).","title":"EVM"},{"location":"develop/compat/evm.html#compatibility-with-the-ethereum-virtual-machine-evm","text":"","title":"Compatibility with the Ethereum Virtual Machine (EVM)"},{"location":"develop/compat/evm.html#precompiles","text":"","title":"Precompiles"},{"location":"develop/compat/evm.html#standard-precompiles","text":"Address ID Name Spec Status 0x01 ECRecover ECDSA public key recovery Yellow Paper \u2705 0x02 SHA256 SHA-2 256-bit hash function Yellow Paper \u2705 0x03 RIPEMD160 RIPEMD 160-bit hash function Yellow Paper \u2705 0x04 Identity Identity function Yellow Paper \u2705 0x05 ModExp Big integer modular exponentation EIP-198 \u2705 0x06 BN128Add Elliptic curve addition EIP-196 \u2705 0x07 BN128Mul Elliptic curve scalar multiplication EIP-196 \u2705 0x08 BN128Pair Elliptic curve pairing check EIP-197 \u2705 0x09 Blake2F BLAKE2b F compression function EIP-152 \u2705","title":"Standard precompiles"},{"location":"develop/compat/evm.html#opcodes","text":"","title":"Opcodes"},{"location":"develop/compat/evm.html#blockhash","text":"This opcode currently does not return a real blockhash. However, it does respect the logic that a non-zero value is returned for the most recent 256 blocks (not including the current block). For all other inputs it returns zero. The non-zero value that is returned is 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff . For example, if the current block height is h , then BLOCKHASH(h) = 0x000... , BLOCKHASH(h - 100) = 0xfff... and BLOCKHASH(h - 257) = 0x000.. . This behavior may change in the future, see nearcore#4256 to track this issue.","title":"BLOCKHASH"},{"location":"develop/compat/evm.html#coinbase","text":"This opcode returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b .","title":"COINBASE"},{"location":"develop/compat/evm.html#difficulty","text":"This opcode always returns zero, since NEAR is not a proof-of-work (PoW) network.","title":"DIFFICULTY"},{"location":"develop/compat/evm.html#gaslimit","text":"This opcode always returns 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff (2^256-1).","title":"GASLIMIT"},{"location":"develop/compat/evm.html#limitations","text":"The Berlin hard fork is not yet supported. The EVM currently supports the feature set of the Istanbul hard fork. The BLOCKHASH opcode currently always returns either 0xfff... (if the input is within 256 blocks) or 0x000... (for the current height or one more than 256 blocks in the past).","title":"Limitations"},{"location":"develop/compat/rpc.html","text":"Compatibility with the Web3 JSON-RPC Protocol \u00b6 Methods \u00b6 Method Status Notes web3_clientVersion \u2705 web3_sha3 \u2705 net_listening \u2705 net_peerCount \u2705 net_version \u2705 eth_accounts \u2705 eth_blockNumber \u2705 eth_call \ud83d\udea7 eth_chainId \u2705 eth_coinbase \u2705 eth_compileLLL \u274c Unsupported eth_compileSerpent \u274c Unsupported eth_compileSolidity \u274c Unsupported eth_estimateGas \u2705 eth_gasPrice \u2705 eth_getBalance \u2705 eth_getBlockByHash \u2705 eth_getBlockByNumber \u2705 eth_getBlockTransactionCountByHash \u2705 eth_getBlockTransactionCountByNumber \u2705 eth_getCode \u2705 eth_getCompilers \u2705 eth_getFilterChanges \ud83d\udea7 eth_getFilterLogs \ud83d\udea7 eth_getLogs \ud83d\udea7 eth_getProof \u274c EIP-1186 eth_getStorageAt \u2705 eth_getTransactionByBlockHashAndIndex \u2705 eth_getTransactionByBlockNumberAndIndex \u2705 eth_getTransactionByHash \ud83d\udea7 eth_getTransactionCount \u2705 eth_getTransactionReceipt \ud83d\udea7 eth_getUncleByBlockHashAndIndex \u2705 eth_getUncleByBlockNumberAndIndex \u2705 eth_getUncleCountByBlockHash \u2705 eth_getUncleCountByBlockNumber \u2705 eth_getWork \u274c Unsupported eth_hashrate \u2705 eth_mining \u2705 eth_newBlockFilter \ud83d\udea7 eth_newFilter \ud83d\udea7 eth_newPendingTransactionFilter \ud83d\udea7 eth_pendingTransactions \u2705 Undocumented eth_protocolVersion \u2705 eth_sendRawTransaction \ud83d\udea7 eth_sendTransaction \ud83d\udea7 eth_sign \ud83d\udea7 eth_signTransaction \ud83d\udea7 eth_signTypedData \ud83d\udea7 EIP-712 eth_submitHashrate \u274c Unsupported eth_submitWork \u274c Unsupported eth_syncing \u2705 eth_uninstallFilter \ud83d\udea7 db_getHex \u274c Deprecated db_getString \u274c Deprecated db_putHex \u274c Deprecated db_putString \u274c Deprecated shh_addToGroup \u274c Discontinued shh_getFilterChanges \u274c Discontinued shh_getMessages \u274c Discontinued shh_hasIdentity \u274c Discontinued shh_newFilter \u274c Discontinued shh_newGroup \u274c Discontinued shh_newIdentity \u274c Discontinued shh_post \u274c Discontinued shh_uninstallFilter \u274c Discontinued shh_version \u274c Discontinued Legend : \u274c = not supported. \ud83d\udea7 = work in progress. \u2705 = supported. Limitations \u00b6 The eth_getProof method ( EIP-1186 ) is not supported and is unlikely to be possible to implement. Notes \u00b6 For now, the eth_estimateGas method returns zero, since no gas is charged. Ethereum is a proof-of-work (PoW) network, and NEAR is a proof-of-stake (PoS) network. Therefore with Aurora all mining-related methods such as eth_getWork , eth_submitHashrate , and eth_submitWork are not supported and return an error code. Additionally, PoW-related block metadata such as nonce and difficulty contain all zeroes. The eth_coinbase method returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b . There is no concept of uncle (aka ommer) blocks. The eth_getUncleByBlockHashAndIndex and eth_getUncleByBlockNumberAndIndex methods always return null . The eth_getUncleCountByBlockHash and eth_getUncleCountByBlockNumber methods return zero for valid block IDs and null for invalid block IDs. Additionally, uncle-related block metadata such as sha3Uncles contain all zeroes. There is no access to pending transactions. The eth_newPendingTransactionFilter method creates a filter that returns nothing when polled with eth_getFilterChanges .","title":"JSON-RPC"},{"location":"develop/compat/rpc.html#compatibility-with-the-web3-json-rpc-protocol","text":"","title":"Compatibility with the Web3 JSON-RPC Protocol"},{"location":"develop/compat/rpc.html#methods","text":"Method Status Notes web3_clientVersion \u2705 web3_sha3 \u2705 net_listening \u2705 net_peerCount \u2705 net_version \u2705 eth_accounts \u2705 eth_blockNumber \u2705 eth_call \ud83d\udea7 eth_chainId \u2705 eth_coinbase \u2705 eth_compileLLL \u274c Unsupported eth_compileSerpent \u274c Unsupported eth_compileSolidity \u274c Unsupported eth_estimateGas \u2705 eth_gasPrice \u2705 eth_getBalance \u2705 eth_getBlockByHash \u2705 eth_getBlockByNumber \u2705 eth_getBlockTransactionCountByHash \u2705 eth_getBlockTransactionCountByNumber \u2705 eth_getCode \u2705 eth_getCompilers \u2705 eth_getFilterChanges \ud83d\udea7 eth_getFilterLogs \ud83d\udea7 eth_getLogs \ud83d\udea7 eth_getProof \u274c EIP-1186 eth_getStorageAt \u2705 eth_getTransactionByBlockHashAndIndex \u2705 eth_getTransactionByBlockNumberAndIndex \u2705 eth_getTransactionByHash \ud83d\udea7 eth_getTransactionCount \u2705 eth_getTransactionReceipt \ud83d\udea7 eth_getUncleByBlockHashAndIndex \u2705 eth_getUncleByBlockNumberAndIndex \u2705 eth_getUncleCountByBlockHash \u2705 eth_getUncleCountByBlockNumber \u2705 eth_getWork \u274c Unsupported eth_hashrate \u2705 eth_mining \u2705 eth_newBlockFilter \ud83d\udea7 eth_newFilter \ud83d\udea7 eth_newPendingTransactionFilter \ud83d\udea7 eth_pendingTransactions \u2705 Undocumented eth_protocolVersion \u2705 eth_sendRawTransaction \ud83d\udea7 eth_sendTransaction \ud83d\udea7 eth_sign \ud83d\udea7 eth_signTransaction \ud83d\udea7 eth_signTypedData \ud83d\udea7 EIP-712 eth_submitHashrate \u274c Unsupported eth_submitWork \u274c Unsupported eth_syncing \u2705 eth_uninstallFilter \ud83d\udea7 db_getHex \u274c Deprecated db_getString \u274c Deprecated db_putHex \u274c Deprecated db_putString \u274c Deprecated shh_addToGroup \u274c Discontinued shh_getFilterChanges \u274c Discontinued shh_getMessages \u274c Discontinued shh_hasIdentity \u274c Discontinued shh_newFilter \u274c Discontinued shh_newGroup \u274c Discontinued shh_newIdentity \u274c Discontinued shh_post \u274c Discontinued shh_uninstallFilter \u274c Discontinued shh_version \u274c Discontinued Legend : \u274c = not supported. \ud83d\udea7 = work in progress. \u2705 = supported.","title":"Methods"},{"location":"develop/compat/rpc.html#limitations","text":"The eth_getProof method ( EIP-1186 ) is not supported and is unlikely to be possible to implement.","title":"Limitations"},{"location":"develop/compat/rpc.html#notes","text":"For now, the eth_estimateGas method returns zero, since no gas is charged. Ethereum is a proof-of-work (PoW) network, and NEAR is a proof-of-stake (PoS) network. Therefore with Aurora all mining-related methods such as eth_getWork , eth_submitHashrate , and eth_submitWork are not supported and return an error code. Additionally, PoW-related block metadata such as nonce and difficulty contain all zeroes. The eth_coinbase method returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b . There is no concept of uncle (aka ommer) blocks. The eth_getUncleByBlockHashAndIndex and eth_getUncleByBlockNumberAndIndex methods always return null . The eth_getUncleCountByBlockHash and eth_getUncleCountByBlockNumber methods return zero for valid block IDs and null for invalid block IDs. Additionally, uncle-related block metadata such as sha3Uncles contain all zeroes. There is no access to pending transactions. The eth_newPendingTransactionFilter method creates a filter that returns nothing when polled with eth_getFilterChanges .","title":"Notes"},{"location":"develop/start/index.html","text":"Getting Started \u00b6","title":"Aurora: Getting Started"},{"location":"develop/start/index.html#getting-started","text":"","title":"Getting Started"},{"location":"develop/start/hardhat.html","text":"Getting Started with Hardhat \u00b6","title":"Aurora: Getting Started with Hardhat"},{"location":"develop/start/hardhat.html#getting-started-with-hardhat","text":"","title":"Getting Started with Hardhat"},{"location":"develop/start/metamask.html","text":"Getting Started with MetaMask \u00b6 MetaMask is a convenient UI for interacting with Ethereum-compatible blockchains (such as Aurora). For the purpose of this guide, we will assume you are already familiar with MetaMask and have it installed. If you need help getting started with MetaMask itself, check out their documentation . In this tutorial we will walk through connecting MetaMask to the Aurora TestNet, deploying a simple ERC-20 contract using Remix , and transferring the new token using MetaMask. Note Screenshots in this tutorial are taken from the MetaMask browser extension version 9.5.5. Connecting MetaMask to Aurora \u00b6 In the top-right corner of the MetaMask interface, click the network selection drop-down and then click Custom RPC . Fill in the form with the following information: Network Name: Aurora TestNet New RPC URL: https://testnet.aurora.dev/ Chain ID: 1313161555 Currency Symbol: ETH Note All the Aurora RPC endpoint URLs and chain IDs can be found on our Networks page. Click Save , and you should see Aurora TestNet is now the network selected in MetaMask. To see MetaMask in action, we will connect it to Remix and perform some transactions. Deploying an ERC-20 Token using Remix \u00b6 In a new tab, open the Remix IDE at remix.ethereum.org . It might take a minute to load, but once it has, create a new file ERC20Token.sol in the workspace panel on the left: Copy and paste the following code into the central editor panel: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/ERC20.sol\" ; contract MyToken is ERC20 { constructor ( string memory name , string memory symbol ) ERC20 ( name , symbol ) { // Mint 100 tokens to msg.sender // Similar to how // 1 dollar = 100 cents // 1 token = 1 * (10 ** decimals) _mint ( msg.sender , 100 * 10 ** uint ( decimals ())); } } This code is a slightly modified (the Solidity compiler and OpenZeppelin versions are newer) version of the example from Solidity by Example . Click the Solidity Compile button on the far left panel (the second icon down); ensure your selected Solidity compiler version is 0.8 (minor versions within 0.8, e.g., 0.8.4 work too), and click Compile ERC20Token.sol . Once the contract is compiled, click the Deploy & run transactions button in the far left panel (the icon below the Solidity compiler). In the ENVIRONMENT drop-down select Injected Web3 . You will see a MetaMask pop-up window asking you to give the Remix IDE permission to access it. Click Next and then Connect to grant access. Back in the Remix interface, click the arrow next to the DEPLOY section of the left panel. Fill in the token details with whatever you like ( MyToken and MT in the example), and click transact . Another MetaMask pop-up will appear asking you to confirm the transaction. Click Confirm . Note You may be surprised to see the gas price set to zero in this transaction. During the early access period Aurora transactions are free, however this will change in the future. Not to worry, even when transaction fees will be non-zero, they'll still be much lower than on the Ethereum 1.0 mainnet. After a few moments the transaction will be confirmed by the network. You will see a success message in the bottom panel and the contract listed under Deployed Contracts on the left panel. Click the copy button to copy the address of the newly deployed contract. Now that the contract is deployed on the Aurora network, we can interact with it via MetaMask. Adding an ERC-20 Token to MetaMask \u00b6 In the MetaMask interface (with the Aurora TestNet network still selected), click the Add Token button: Paste the token address copied from Remix in the previous step. The remaining token details should fill in automatically as MetaMask finds the contract on-chain. Click Next : On the next screen you see the balance (100 tokens), as minted in our contract constructor. Click Add Tokens : The token has now been added to MetaMask and we can use the MetaMask interface to view the token balance and to transfer the token to others. Transferring an ERC-20 Token with MetaMask \u00b6 Continuing from the previous step, click the Send button in the MetaMask interface: Select a recipient (if you have multiple accounts in MetaMask you can simply select another account), and an amount of tokens to send. Click Next : Note Once again the gas price should be set to zero, but this will change going forward. Click Confirm to send the transaction to the network: After a few moments the transaction will be confirmed by the network. You can see the updated balance your account holds in the MetaMask interface: If you transferred to another MetaMask account you hold then you can follow the aforementioned instructions for adding the token to MetaMask on the other account, and view its balance also. Summary \u00b6 In this tutorial we connected MetaMask to the Aurora TestNet, deployed an ERC-20 token contract using Remix, and transferred that token using MetaMask. The only difference to doing this on the original Ethereum network was setting the RPC endpoint to be Aurora's.","title":"MetaMask"},{"location":"develop/start/metamask.html#getting-started-with-metamask","text":"MetaMask is a convenient UI for interacting with Ethereum-compatible blockchains (such as Aurora). For the purpose of this guide, we will assume you are already familiar with MetaMask and have it installed. If you need help getting started with MetaMask itself, check out their documentation . In this tutorial we will walk through connecting MetaMask to the Aurora TestNet, deploying a simple ERC-20 contract using Remix , and transferring the new token using MetaMask. Note Screenshots in this tutorial are taken from the MetaMask browser extension version 9.5.5.","title":"Getting Started with MetaMask"},{"location":"develop/start/metamask.html#connecting-metamask-to-aurora","text":"In the top-right corner of the MetaMask interface, click the network selection drop-down and then click Custom RPC . Fill in the form with the following information: Network Name: Aurora TestNet New RPC URL: https://testnet.aurora.dev/ Chain ID: 1313161555 Currency Symbol: ETH Note All the Aurora RPC endpoint URLs and chain IDs can be found on our Networks page. Click Save , and you should see Aurora TestNet is now the network selected in MetaMask. To see MetaMask in action, we will connect it to Remix and perform some transactions.","title":"Connecting MetaMask to Aurora"},{"location":"develop/start/metamask.html#deploying-an-erc-20-token-using-remix","text":"In a new tab, open the Remix IDE at remix.ethereum.org . It might take a minute to load, but once it has, create a new file ERC20Token.sol in the workspace panel on the left: Copy and paste the following code into the central editor panel: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/ERC20.sol\" ; contract MyToken is ERC20 { constructor ( string memory name , string memory symbol ) ERC20 ( name , symbol ) { // Mint 100 tokens to msg.sender // Similar to how // 1 dollar = 100 cents // 1 token = 1 * (10 ** decimals) _mint ( msg.sender , 100 * 10 ** uint ( decimals ())); } } This code is a slightly modified (the Solidity compiler and OpenZeppelin versions are newer) version of the example from Solidity by Example . Click the Solidity Compile button on the far left panel (the second icon down); ensure your selected Solidity compiler version is 0.8 (minor versions within 0.8, e.g., 0.8.4 work too), and click Compile ERC20Token.sol . Once the contract is compiled, click the Deploy & run transactions button in the far left panel (the icon below the Solidity compiler). In the ENVIRONMENT drop-down select Injected Web3 . You will see a MetaMask pop-up window asking you to give the Remix IDE permission to access it. Click Next and then Connect to grant access. Back in the Remix interface, click the arrow next to the DEPLOY section of the left panel. Fill in the token details with whatever you like ( MyToken and MT in the example), and click transact . Another MetaMask pop-up will appear asking you to confirm the transaction. Click Confirm . Note You may be surprised to see the gas price set to zero in this transaction. During the early access period Aurora transactions are free, however this will change in the future. Not to worry, even when transaction fees will be non-zero, they'll still be much lower than on the Ethereum 1.0 mainnet. After a few moments the transaction will be confirmed by the network. You will see a success message in the bottom panel and the contract listed under Deployed Contracts on the left panel. Click the copy button to copy the address of the newly deployed contract. Now that the contract is deployed on the Aurora network, we can interact with it via MetaMask.","title":"Deploying an ERC-20 Token using Remix"},{"location":"develop/start/metamask.html#adding-an-erc-20-token-to-metamask","text":"In the MetaMask interface (with the Aurora TestNet network still selected), click the Add Token button: Paste the token address copied from Remix in the previous step. The remaining token details should fill in automatically as MetaMask finds the contract on-chain. Click Next : On the next screen you see the balance (100 tokens), as minted in our contract constructor. Click Add Tokens : The token has now been added to MetaMask and we can use the MetaMask interface to view the token balance and to transfer the token to others.","title":"Adding an ERC-20 Token to MetaMask"},{"location":"develop/start/metamask.html#transferring-an-erc-20-token-with-metamask","text":"Continuing from the previous step, click the Send button in the MetaMask interface: Select a recipient (if you have multiple accounts in MetaMask you can simply select another account), and an amount of tokens to send. Click Next : Note Once again the gas price should be set to zero, but this will change going forward. Click Confirm to send the transaction to the network: After a few moments the transaction will be confirmed by the network. You can see the updated balance your account holds in the MetaMask interface: If you transferred to another MetaMask account you hold then you can follow the aforementioned instructions for adding the token to MetaMask on the other account, and view its balance also.","title":"Transferring an ERC-20 Token with MetaMask"},{"location":"develop/start/metamask.html#summary","text":"In this tutorial we connected MetaMask to the Aurora TestNet, deployed an ERC-20 token contract using Remix, and transferred that token using MetaMask. The only difference to doing this on the original Ethereum network was setting the RPC endpoint to be Aurora's.","title":"Summary"},{"location":"develop/start/truffle.html","text":"Deploying a Contract Using Truffle \u00b6 Introduction \u00b6 Truffle is a widely used development environment and testing framework for Ethereum smart contracts. In this tutorial, we will show by example how to use Truffle with the Aurora TestNet. This tutorial assumes that you are familiar with Truffle and the non-fungible tokens (NFT) concept. For more details about the non-fungible token standard, please refer to the ERC-721 Non-Fungible Token Standard specification. NFT Example \u00b6 This example is originally forked from the OpenZeppelin examples . However, the code has been changed to fit the use case of this tutorial. The use case is about how to deploy and manage the life cycle of a simple COVID-19 vaccine NFT token \ud83d\udc8a\ud83d\udc8a using Truffle on the Aurora TestNet. The minter address (which is managed by the vaccination program manager) can distribute (mint) the vaccine tickets (NFT tokens \ud83d\udc8a\ud83d\udc8a\ud83d\udc8a) to the people who are part of the vaccination program. When participants receive the tokens \ud83d\udc8a, they can get access to the vaccine by spending the NFT token. This means either burning the NFT token or sending it back to the minter address. If the participant chooses to send it back then the minter can redistribute that token \ud83c\udfab to another participant in the line. Then the new participant will have access to the same vaccine token that has been used by the previous participant. Installing Prerequisites \u00b6 This tutorial assumes that you have Node.js 12+ and Yarn. Please refer to the Yarn installation how-to if you don't yet have the yarn command installed locally. To install the prerequisite packages, clone the examples repository and then run yarn : Install Truffle \u00b6 npm install -g truffle Install dependencies \u00b6 git clone https://github.com/aurora-is-near/aurora-examples.git cd aurora-examples/truffle/erc721-example/ yarn Connecting Truffle to Aurora \u00b6 Export your MNEMONIC as follows: export MNEMONIC = 'YOUR MNEMONIC HERE' Now in truffle-config.js , you will need to change the from address as shown below in the aurora network section: ... aurora : { provider : () => se tu pWalle t ('h tt ps : // testnet .aurora.dev') , net work_id : 0 x 4e454153 , gas : 10000000 , fr om : ' 0 x 6 A 33382 de 9 f 73 B 846878 a 57500 d 055 B 981229 ac 4 ' // CHANGE THIS ADDRESS }, The truffle-config.js configuration will pick up your MNEMONIC environmen variable and recover the address that will be used for sending and signing transactions on the Aurora network. Deploying the Contract \u00b6 To deploy the CovidVaccineToken contract, you can run the yarn command as follows: yarn deploy:aurora .... _deploy_contracts.js ===================== Deploying 'CovidVaccineToken' ----------------------------- > transaction hash: 0x282012c791d65d0ce2fd1fd9fcc41179dba5bd06c3b02e31e53dbe9cc8af62c1 > Blocks: 7 Seconds: 5 > contract address: 0x3635D999d8CdA2fAf304b390fb26a9c2f364dFbd > block number: 49151611 > block timestamp: 1622034185 > account: 0x6A33382de9f73B846878a57500d055B981229ac4 > balance: 0 > gas used: 2576274 ( 0x274f92 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .05152548 ETH .... Playing with the Truffle Console \u00b6 Now you can test the flow as mentioned in the NFT Example section: Mint tokens \u00b6 The minter mints and transfers NFT tokens for the vaccine program participant. In this example, the new participant address is 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe and the minter address is 0x6A33382de9f73B846878a57500d055B981229ac4 . Please make sure that you are using the same deployer address as a minter address, otherwise the mint transaction will revert. % truffle console --network aurora truffle ( aurora ) > const cvt = await CovidVaccineToken.deployed () truffle ( aurora ) > await cvt.minter () '0x6A33382de9f73B846878a57500d055B981229ac4' truffle ( aurora ) > await cvt.mint ( '0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe' , { from: accounts [ 0 ]}) You should notice that accounts[0] is the minter address and none of the participants are allowed to transfer their NFT tokens except for the minter. So let's try to use any participant address to validate this. To do that, change the value of from to accounts[1] , so that the sender will be the first participant (e.g., the participant address 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe ). In the Truffle console: truffle ( aurora ) > await cvt.safeTransferFrom ( '0x2531a4d108619a20acee88c4354a50e9ac48ecfe' , '0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771' , 1 , { from: accounts [ 1 ]}) Uncaught Error: execution reverted: ... reason: 'Invalid Transfer' , hijackedStack: 'Error: execution reverted:\\n' This is exactly the same error message we have in our NFT contract in safeTransferFrom : function safeTransferFrom ( address from , address to , uint256 tokenId ) public virtual override { require ( minter == msg.sender || to == minter , 'Invalid Transfer' ); safeTransferFrom ( from , to , tokenId , \"\" ); } Transfer tokens \u00b6 Participants can transfer the token to the minter after receiving the vaccine. As shown below, a participant can only send the NFT token if the receiver for this token is the minter ( 0x6A33382de9f73B846878a57500d055B981229ac4 ). truffle ( aurora ) > await cvt.ownerOf ( 1 ) // TokenID 1 '0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe' truffle ( aurora ) > await cvt.minter () '0x6A33382de9f73B846878a57500d055B981229ac4' truffle ( aurora ) > await cvt.safeTransferFrom ( '0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe' , '0x6A33382de9f73B846878a57500d055B981229ac4' , 1 , { from: accounts [ 1 ]}) truffle ( aurora ) > await cvt.ownerOf ( 1 ) // TokenID 1 '0x6A33382de9f73B846878a57500d055B981229ac4' Burn tokens \u00b6 This is an alternative scenario for the NFT token lifecycle. Instead of transfering the token back to the minter, the participant can decide to burn the NFT token by calling the burn function: truffle ( aurora ) > await cvt.burn ( 1 , { from: accounts [ 1 ]}) // 1 is the tokenID Redistribute tokens \u00b6 Finally, the minter can send the same token (if not burnt) to a new participant in the line: truffle ( aurora ) > await cvt.safeTransferFrom ( '0x6A33382de9f73B846878a57500d055B981229ac4' , '0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771' , 1 , { from: accounts [ 0 ]}) truffle ( aurora ) > await cvt.ownerOf ( 1 ) '0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771' Summary \u00b6 In this simple tutorial, we deployed an NFT contract to the Aurora TestNet using Truffle and interacted with the contract's functions.","title":"Truffle"},{"location":"develop/start/truffle.html#deploying-a-contract-using-truffle","text":"","title":"Deploying a Contract Using Truffle"},{"location":"develop/start/truffle.html#introduction","text":"Truffle is a widely used development environment and testing framework for Ethereum smart contracts. In this tutorial, we will show by example how to use Truffle with the Aurora TestNet. This tutorial assumes that you are familiar with Truffle and the non-fungible tokens (NFT) concept. For more details about the non-fungible token standard, please refer to the ERC-721 Non-Fungible Token Standard specification.","title":"Introduction"},{"location":"develop/start/truffle.html#nft-example","text":"This example is originally forked from the OpenZeppelin examples . However, the code has been changed to fit the use case of this tutorial. The use case is about how to deploy and manage the life cycle of a simple COVID-19 vaccine NFT token \ud83d\udc8a\ud83d\udc8a using Truffle on the Aurora TestNet. The minter address (which is managed by the vaccination program manager) can distribute (mint) the vaccine tickets (NFT tokens \ud83d\udc8a\ud83d\udc8a\ud83d\udc8a) to the people who are part of the vaccination program. When participants receive the tokens \ud83d\udc8a, they can get access to the vaccine by spending the NFT token. This means either burning the NFT token or sending it back to the minter address. If the participant chooses to send it back then the minter can redistribute that token \ud83c\udfab to another participant in the line. Then the new participant will have access to the same vaccine token that has been used by the previous participant.","title":"NFT Example"},{"location":"develop/start/truffle.html#installing-prerequisites","text":"This tutorial assumes that you have Node.js 12+ and Yarn. Please refer to the Yarn installation how-to if you don't yet have the yarn command installed locally. To install the prerequisite packages, clone the examples repository and then run yarn :","title":"Installing Prerequisites"},{"location":"develop/start/truffle.html#install-truffle","text":"npm install -g truffle","title":"Install Truffle"},{"location":"develop/start/truffle.html#install-dependencies","text":"git clone https://github.com/aurora-is-near/aurora-examples.git cd aurora-examples/truffle/erc721-example/ yarn","title":"Install dependencies"},{"location":"develop/start/truffle.html#connecting-truffle-to-aurora","text":"Export your MNEMONIC as follows: export MNEMONIC = 'YOUR MNEMONIC HERE' Now in truffle-config.js , you will need to change the from address as shown below in the aurora network section: ... aurora : { provider : () => se tu pWalle t ('h tt ps : // testnet .aurora.dev') , net work_id : 0 x 4e454153 , gas : 10000000 , fr om : ' 0 x 6 A 33382 de 9 f 73 B 846878 a 57500 d 055 B 981229 ac 4 ' // CHANGE THIS ADDRESS }, The truffle-config.js configuration will pick up your MNEMONIC environmen variable and recover the address that will be used for sending and signing transactions on the Aurora network.","title":"Connecting Truffle to Aurora"},{"location":"develop/start/truffle.html#deploying-the-contract","text":"To deploy the CovidVaccineToken contract, you can run the yarn command as follows: yarn deploy:aurora .... _deploy_contracts.js ===================== Deploying 'CovidVaccineToken' ----------------------------- > transaction hash: 0x282012c791d65d0ce2fd1fd9fcc41179dba5bd06c3b02e31e53dbe9cc8af62c1 > Blocks: 7 Seconds: 5 > contract address: 0x3635D999d8CdA2fAf304b390fb26a9c2f364dFbd > block number: 49151611 > block timestamp: 1622034185 > account: 0x6A33382de9f73B846878a57500d055B981229ac4 > balance: 0 > gas used: 2576274 ( 0x274f92 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .05152548 ETH ....","title":"Deploying the Contract"},{"location":"develop/start/truffle.html#playing-with-the-truffle-console","text":"Now you can test the flow as mentioned in the NFT Example section:","title":"Playing with the Truffle Console"},{"location":"develop/start/truffle.html#mint-tokens","text":"The minter mints and transfers NFT tokens for the vaccine program participant. In this example, the new participant address is 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe and the minter address is 0x6A33382de9f73B846878a57500d055B981229ac4 . Please make sure that you are using the same deployer address as a minter address, otherwise the mint transaction will revert. % truffle console --network aurora truffle ( aurora ) > const cvt = await CovidVaccineToken.deployed () truffle ( aurora ) > await cvt.minter () '0x6A33382de9f73B846878a57500d055B981229ac4' truffle ( aurora ) > await cvt.mint ( '0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe' , { from: accounts [ 0 ]}) You should notice that accounts[0] is the minter address and none of the participants are allowed to transfer their NFT tokens except for the minter. So let's try to use any participant address to validate this. To do that, change the value of from to accounts[1] , so that the sender will be the first participant (e.g., the participant address 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe ). In the Truffle console: truffle ( aurora ) > await cvt.safeTransferFrom ( '0x2531a4d108619a20acee88c4354a50e9ac48ecfe' , '0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771' , 1 , { from: accounts [ 1 ]}) Uncaught Error: execution reverted: ... reason: 'Invalid Transfer' , hijackedStack: 'Error: execution reverted:\\n' This is exactly the same error message we have in our NFT contract in safeTransferFrom : function safeTransferFrom ( address from , address to , uint256 tokenId ) public virtual override { require ( minter == msg.sender || to == minter , 'Invalid Transfer' ); safeTransferFrom ( from , to , tokenId , \"\" ); }","title":"Mint tokens"},{"location":"develop/start/truffle.html#transfer-tokens","text":"Participants can transfer the token to the minter after receiving the vaccine. As shown below, a participant can only send the NFT token if the receiver for this token is the minter ( 0x6A33382de9f73B846878a57500d055B981229ac4 ). truffle ( aurora ) > await cvt.ownerOf ( 1 ) // TokenID 1 '0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe' truffle ( aurora ) > await cvt.minter () '0x6A33382de9f73B846878a57500d055B981229ac4' truffle ( aurora ) > await cvt.safeTransferFrom ( '0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe' , '0x6A33382de9f73B846878a57500d055B981229ac4' , 1 , { from: accounts [ 1 ]}) truffle ( aurora ) > await cvt.ownerOf ( 1 ) // TokenID 1 '0x6A33382de9f73B846878a57500d055B981229ac4'","title":"Transfer tokens"},{"location":"develop/start/truffle.html#burn-tokens","text":"This is an alternative scenario for the NFT token lifecycle. Instead of transfering the token back to the minter, the participant can decide to burn the NFT token by calling the burn function: truffle ( aurora ) > await cvt.burn ( 1 , { from: accounts [ 1 ]}) // 1 is the tokenID","title":"Burn tokens"},{"location":"develop/start/truffle.html#redistribute-tokens","text":"Finally, the minter can send the same token (if not burnt) to a new participant in the line: truffle ( aurora ) > await cvt.safeTransferFrom ( '0x6A33382de9f73B846878a57500d055B981229ac4' , '0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771' , 1 , { from: accounts [ 0 ]}) truffle ( aurora ) > await cvt.ownerOf ( 1 ) '0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771'","title":"Redistribute tokens"},{"location":"develop/start/truffle.html#summary","text":"In this simple tutorial, we deployed an NFT contract to the Aurora TestNet using Truffle and interacted with the contract's functions.","title":"Summary"},{"location":"integrate/index.html","text":"","title":"Index"},{"location":"learn/index.html","text":"Tutorials \u00b6","title":"Aurora: Tutorials"},{"location":"learn/index.html#tutorials","text":"","title":"Tutorials"},{"location":"learn/bridge/index.html","text":"Bridging from/to Ethereum \u00b6 Bridging from Ethereum \u00b6 Bridging to Ethereum \u00b6","title":"Aurora: Bridging from/to Ethereum"},{"location":"learn/bridge/index.html#bridging-fromto-ethereum","text":"","title":"Bridging from/to Ethereum"},{"location":"learn/bridge/index.html#bridging-from-ethereum","text":"","title":"Bridging from Ethereum"},{"location":"learn/bridge/index.html#bridging-to-ethereum","text":"","title":"Bridging to Ethereum"},{"location":"learn/bridge/erc-20.html","text":"Bridging ERC-20 Tokens \u00b6","title":"Aurora: Bridging ERC-20 Tokens"},{"location":"learn/bridge/erc-20.html#bridging-erc-20-tokens","text":"","title":"Bridging ERC-20 Tokens"},{"location":"learn/bridge/eth.html","text":"Bridging ETH Balances \u00b6","title":"Aurora: Bridging ETH Balances"},{"location":"learn/bridge/eth.html#bridging-eth-balances","text":"","title":"Bridging ETH Balances"},{"location":"learn/connect/index.html","text":"Connecting a Wallet \u00b6","title":"Aurora: Connecting a Wallet"},{"location":"learn/connect/index.html#connecting-a-wallet","text":"","title":"Connecting a Wallet"},{"location":"learn/connect/metamask.html","text":"Connecting with MetaMask \u00b6","title":"Aurora: Connecting with MetaMask"},{"location":"learn/connect/metamask.html#connecting-with-metamask","text":"","title":"Connecting with MetaMask"},{"location":"learn/connect/walletconnect.html","text":"Connecting with WalletConnect \u00b6","title":"Aurora: Connecting with WalletConnect"},{"location":"learn/connect/walletconnect.html#connecting-with-walletconnect","text":"","title":"Connecting with WalletConnect"},{"location":"learn/deploy/index.html","text":"Deploying a Contract \u00b6","title":"Aurora: Deploying a Contract"},{"location":"learn/deploy/index.html#deploying-a-contract","text":"","title":"Deploying a Contract"},{"location":"learn/deploy/hardhat.html","text":"Deploying a Contract Using Hardhat \u00b6","title":"Aurora: Deploying a Contract Using Hardhat"},{"location":"learn/deploy/hardhat.html#deploying-a-contract-using-hardhat","text":"","title":"Deploying a Contract Using Hardhat"},{"location":"learn/deploy/remix.html","text":"Deploying a Contract Using Remix \u00b6","title":"Aurora: Deploying a Contract Using Remix"},{"location":"learn/deploy/remix.html#deploying-a-contract-using-remix","text":"","title":"Deploying a Contract Using Remix"},{"location":"learn/deploy/truffle.html","text":"Deploying a Contract Using Truffle \u00b6","title":"Aurora: Deploying a Contract Using Truffle"},{"location":"learn/deploy/truffle.html#deploying-a-contract-using-truffle","text":"","title":"Deploying a Contract Using Truffle"},{"location":"learn/interact/index.html","text":"Interacting with Contracts \u00b6","title":"Aurora: Interacting with Contracts"},{"location":"learn/interact/index.html#interacting-with-contracts","text":"","title":"Interacting with Contracts"},{"location":"learn/interact/remix.html","text":"Interacting with Contracts Using Remix \u00b6","title":"Aurora: Interacting with Contracts Using Remix"},{"location":"learn/interact/remix.html#interacting-with-contracts-using-remix","text":"","title":"Interacting with Contracts Using Remix"}]}