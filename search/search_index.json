{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Project Aurora \u00b6 Here be dragons This documentation is a work in progress and may contain incomplete, inaccurate, or outdated information. Aurora is an Ethereum Virtual Machine (EVM) on the NEAR Protocol blockchain, delivering a turn-key solution for developers to operate their apps on an Ethereum-compatible, high-throughput, scalable, and future-safe platform, with low transaction costs for their users. Aurora provides the Ethereum 1.0 development experience, with layer-2-like speed and scalability. If you are an Ethereum developer, getting starting on Aurora is as easy as changing the RPC endpoint you interact with. If you're ready to dive in check out our Develop page for more information. The capabilities of Aurora are possible because it is built on top of NEAR . NEAR is a modern layer-1 blockchain which is fast (2-3 second transaction finalization), scalable, and carbon neutral . Even though NEAR is a separate blockchain from Ethereum, Aurora aims for full compatibility with Ethereum development tools such as Truffle and Hardhat . Additionally, NEAR's trustless bridge to Ethereum means even the assets on Aurora are the same as Ethereum. For example, account balances in Aurora's EVM are denominated in the same Ether (ETH) as on Ethereum itself. Still have questions? Check out our answers to frequently asked questions (FAQs) .","title":"Overview"},{"location":"index.html#welcome-to-project-aurora","text":"Here be dragons This documentation is a work in progress and may contain incomplete, inaccurate, or outdated information. Aurora is an Ethereum Virtual Machine (EVM) on the NEAR Protocol blockchain, delivering a turn-key solution for developers to operate their apps on an Ethereum-compatible, high-throughput, scalable, and future-safe platform, with low transaction costs for their users. Aurora provides the Ethereum 1.0 development experience, with layer-2-like speed and scalability. If you are an Ethereum developer, getting starting on Aurora is as easy as changing the RPC endpoint you interact with. If you're ready to dive in check out our Develop page for more information. The capabilities of Aurora are possible because it is built on top of NEAR . NEAR is a modern layer-1 blockchain which is fast (2-3 second transaction finalization), scalable, and carbon neutral . Even though NEAR is a separate blockchain from Ethereum, Aurora aims for full compatibility with Ethereum development tools such as Truffle and Hardhat . Additionally, NEAR's trustless bridge to Ethereum means even the assets on Aurora are the same as Ethereum. For example, account balances in Aurora's EVM are denominated in the same Ether (ETH) as on Ethereum itself. Still have questions? Check out our answers to frequently asked questions (FAQs) .","title":"Welcome to Project Aurora"},{"location":"media.html","text":"Media Kit \u00b6","title":"Aurora: Media Kit"},{"location":"media.html#media-kit","text":"","title":"Media Kit"},{"location":"develop/index.html","text":"","title":"Index"},{"location":"develop/changelog.html","text":"Changelog \u00b6 2021-06-18 \u00b6 Testnet & Betanet only \u00b6 Aurora Engine : Deployed release 1.4.0 to Testnet and Betanet. 2021-06-17 \u00b6 All endpoints \u00b6 Aurora Relayer : Fixed a bug in handling empty log event data properties. This affected the eth_getFilterLogs , eth_getLogs , and eth_getTransactionReceipt RPC methods. ( df29187 ) Testnet & Betanet only \u00b6 Aurora Engine : Deployed release 1.3.0 to Testnet and Betanet. 2021-06-11 \u00b6 The weekly update Testnet & Betanet only \u00b6 Aurora Engine : Deployed release 1.2.0 to Testnet and Betanet. 2021-06-09 \u00b6 All endpoints \u00b6 Aurora Relayer : Fixed a bug in the eth_getFilterChanges RPC method's return value: the data property must never be null . ( f0a41f1 ) 2021-06-04 \u00b6 The weekly update All endpoints \u00b6 Aurora Relayer : Fixed a bug in the eth_getTransactionByHash RPC method's return value: an empty input property must be returned as \"0x\" , not null . ( 8cd353e ) 2021-06-02 \u00b6 All endpoints \u00b6 Aurora Relayer : Changed the eth_estimateGas RPC method's return value to 6,721,975, to match Truffle's default gas limit. ( d8c672c , #16 ) Aurora Relayer : Ensured that the eth_sendRawTransaction RPC method rejects transactions that have a gas limit lower than the minimum 21,000. ( 87b96ed , #17 ) Aurora Relayer : Bumped the eth_estimateGas RPC method's return value from zero to 300,000, sufficient to cover most MetaMask transactions. ( 6797a94 , #16 ) 2021-05-29 \u00b6 Testnet only \u00b6 Aurora Engine : Deployed release 1.1.0 to Testnet. 2021-05-28 \u00b6 The weekly update 2021-05-24 \u00b6 All endpoints \u00b6 Aurora Relayer : Fixed a bug in the eth_call RPC method. This had been affecting MetaMask users in particular. ( 1d0d7cd ) 2021-05-19 \u00b6 We have rolled out new endpoint URLs . Changing from the former endpoint URL https://rpc.$NETWORK.aurora.dev:8545 to https://$NETWORK.aurora.dev is recommended and will decrease your response latency and increase your rate limits. 2021-05-17 \u00b6 All endpoints \u00b6 Aurora Relayer : Fixed a response encoding discrepancy with the eth_getTransactionReceipt RPC method which was causing Truffle to believe that the transaction reverted when deploying contracts. ( 2500fd9 ) 2021-05-13 \u00b6 All endpoints \u00b6 Aurora Relayer : Fixed a regression in the eth_getTransactionReceipt RPC method. ( 07dc0da ) Fixed the CORS preflight response by ensuring that the response has status code 204 and contains the Access-Control-Allow-Origin: * and Access-Control-Allow-Methods: OPTIONS, POST headers. 2021-05-12 \u00b6 Launched Aurora publicly . All networks \u00b6 Aurora Engine : Deployed release 1.0.0 to Mainnet, Testnet, and Betanet.","title":"Changelog"},{"location":"develop/changelog.html#changelog","text":"","title":"Changelog"},{"location":"develop/changelog.html#2021-06-18","text":"","title":"2021-06-18"},{"location":"develop/changelog.html#testnet-betanet-only","text":"Aurora Engine : Deployed release 1.4.0 to Testnet and Betanet.","title":"Testnet &amp; Betanet only"},{"location":"develop/changelog.html#2021-06-17","text":"","title":"2021-06-17"},{"location":"develop/changelog.html#all-endpoints","text":"Aurora Relayer : Fixed a bug in handling empty log event data properties. This affected the eth_getFilterLogs , eth_getLogs , and eth_getTransactionReceipt RPC methods. ( df29187 )","title":"All endpoints"},{"location":"develop/changelog.html#testnet-betanet-only_1","text":"Aurora Engine : Deployed release 1.3.0 to Testnet and Betanet.","title":"Testnet &amp; Betanet only"},{"location":"develop/changelog.html#2021-06-11","text":"The weekly update","title":"2021-06-11"},{"location":"develop/changelog.html#testnet-betanet-only_2","text":"Aurora Engine : Deployed release 1.2.0 to Testnet and Betanet.","title":"Testnet &amp; Betanet only"},{"location":"develop/changelog.html#2021-06-09","text":"","title":"2021-06-09"},{"location":"develop/changelog.html#all-endpoints_1","text":"Aurora Relayer : Fixed a bug in the eth_getFilterChanges RPC method's return value: the data property must never be null . ( f0a41f1 )","title":"All endpoints"},{"location":"develop/changelog.html#2021-06-04","text":"The weekly update","title":"2021-06-04"},{"location":"develop/changelog.html#all-endpoints_2","text":"Aurora Relayer : Fixed a bug in the eth_getTransactionByHash RPC method's return value: an empty input property must be returned as \"0x\" , not null . ( 8cd353e )","title":"All endpoints"},{"location":"develop/changelog.html#2021-06-02","text":"","title":"2021-06-02"},{"location":"develop/changelog.html#all-endpoints_3","text":"Aurora Relayer : Changed the eth_estimateGas RPC method's return value to 6,721,975, to match Truffle's default gas limit. ( d8c672c , #16 ) Aurora Relayer : Ensured that the eth_sendRawTransaction RPC method rejects transactions that have a gas limit lower than the minimum 21,000. ( 87b96ed , #17 ) Aurora Relayer : Bumped the eth_estimateGas RPC method's return value from zero to 300,000, sufficient to cover most MetaMask transactions. ( 6797a94 , #16 )","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-29","text":"","title":"2021-05-29"},{"location":"develop/changelog.html#testnet-only","text":"Aurora Engine : Deployed release 1.1.0 to Testnet.","title":"Testnet only"},{"location":"develop/changelog.html#2021-05-28","text":"The weekly update","title":"2021-05-28"},{"location":"develop/changelog.html#2021-05-24","text":"","title":"2021-05-24"},{"location":"develop/changelog.html#all-endpoints_4","text":"Aurora Relayer : Fixed a bug in the eth_call RPC method. This had been affecting MetaMask users in particular. ( 1d0d7cd )","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-19","text":"We have rolled out new endpoint URLs . Changing from the former endpoint URL https://rpc.$NETWORK.aurora.dev:8545 to https://$NETWORK.aurora.dev is recommended and will decrease your response latency and increase your rate limits.","title":"2021-05-19"},{"location":"develop/changelog.html#2021-05-17","text":"","title":"2021-05-17"},{"location":"develop/changelog.html#all-endpoints_5","text":"Aurora Relayer : Fixed a response encoding discrepancy with the eth_getTransactionReceipt RPC method which was causing Truffle to believe that the transaction reverted when deploying contracts. ( 2500fd9 )","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-13","text":"","title":"2021-05-13"},{"location":"develop/changelog.html#all-endpoints_6","text":"Aurora Relayer : Fixed a regression in the eth_getTransactionReceipt RPC method. ( 07dc0da ) Fixed the CORS preflight response by ensuring that the response has status code 204 and contains the Access-Control-Allow-Origin: * and Access-Control-Allow-Methods: OPTIONS, POST headers.","title":"All endpoints"},{"location":"develop/changelog.html#2021-05-12","text":"Launched Aurora publicly .","title":"2021-05-12"},{"location":"develop/changelog.html#all-networks","text":"Aurora Engine : Deployed release 1.0.0 to Mainnet, Testnet, and Betanet.","title":"All networks"},{"location":"develop/faq.html","text":"Frequently Asked Questions \u00b6 I'm an app developer. Why should I choose Aurora over other EVMs? \u00b6 Aurora was built by the same team that created the NEAR Protocol, considered to be among the most highly regarded blockchain technologies in the crypto space. Although created at NEAR, Aurora will be exist as a separate entity, governed by the decentralized AuroraDAO, and will leverage the unique underlying NEAR technologies to align incentives of the network, product owners, and end users. When you choose to deploy your app on Aurora, you\u2019re partnering with a highly-capable and dedicated organization, and building upon a technical foundation that will scale to meet all your future needs. What are the basic performance metrics? \u00b6 Aurora is a major use case for the NEAR blockchain that requires many changes on different levels. At the moment we\u2019re waiting for NEAR validators to accept the protocol change that will add EVM precompiles. We expect this to happen in the first half of the summer. After this protocol upgrade one can expect Aurora to be able to host twice the throughput of the Ethereum Mainnet. There\u2019s still a lot of room for a single-shard Aurora improvement, so we expect further throughput increases. How will transaction fees work? \u00b6 The base fee token of Aurora is ETH, which will make your users feel right at home. By leveraging the underlying low-cost capabilities of the NEAR Protocol, Aurora transactions will typically cost pennies. What\u2019s particularly interesting, is that the underlying fee model of NEAR opens the door to innovative possibilities, such as AuroraDAO directed mechanisms of channeling a portion of collected fees back to the projects running on Aurora! What does the high-level roadmap look like? \u00b6 While the detailed Aurora roadmap is available on the web site , in general, over the course of summer we plan to optimise Aurora and take care of the DAO formation and token development (if this is decided by the DAO). In Autumn, we plan to deliver several major features, such as introduction of fast bridging of the most popular tokens, ability to pay fees in stable coins and simplified UX for non-blockchain users. We\u2019re planning to deliver a sharded version of Aurora early next year. How do I get started with Aurora? \u00b6 The Aurora EVM has been deployed on the NEAR Mainnet and Testnet networks. Asset connectors\u2014e.g. our \u201cETH Connector\u201d and \u201cERC-20 Connectors\u201d\u2014allow asset transfers between Aurora and Ethereum, using the Aurora Bridge. Currently, the ETH Connector is deployed and functional on Testnet, with the ERC-20 Connector soon to follow. In this way, project owners should be able to test their deployments on Aurora fully in May, followed by production deployments in June of 2021. For those interested in getting started, a set of Aurora Documents is currently available. How will bridging tokens between Ethereum and Aurora work? \u00b6 Very easy! You'll select the direction of transfer, the token you want to transfer, and the amount. Your address on Aurora will be the same as your Ethereum address. The Aurora Bridge will initially work with MetaMask. To access your tokens and apps on Aurora, you\u2019ll need to add Aurora as an additional network to MetaMask, and the Bridge will help you with that. Which tokens will be supported? \u00b6 Initially, ETH\u2014the base fee token of Aurora\u2014will be supported, followed by a select list of popular ERC-20 tokens, and then any arbitrary assets. This rollout is planned to take place during May and June of 2021. How long will transfers take? \u00b6 To ensure security, transfers to Aurora take about 10 minutes, and transfers back to Ethereum take about a day. As you can see from our roadmap, we\u2019ll be dramatically improving those transfer times by Autumn of 2021. Why will transfers take so long? \u00b6 The Aurora Bridge technical architecture is designed to be \u201ctrustless\u201d, meaning there\u2019s no reliance on third-parties for authorizations. Trustless transfers align with the ethos of decentralized finance, but do require more time, given that network confirmations to ensure transaction finality. There are, however, technical ways in which we can, and will, shorten transfer times in future updates to the bridge. Will I be able to initiate multiple transfers in parallel? \u00b6 Yes! Since confirmation of transfer can take a while, you\u2019ll be able to initiate any number of concurrent transfers. I have a few more questions. Where can I get help? \u00b6 For support and help with any questions, don't hesitate to reach out on Telegram channels: official channel , support channel , development channel .","title":"FAQs"},{"location":"develop/faq.html#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"develop/faq.html#im-an-app-developer-why-should-i-choose-aurora-over-other-evms","text":"Aurora was built by the same team that created the NEAR Protocol, considered to be among the most highly regarded blockchain technologies in the crypto space. Although created at NEAR, Aurora will be exist as a separate entity, governed by the decentralized AuroraDAO, and will leverage the unique underlying NEAR technologies to align incentives of the network, product owners, and end users. When you choose to deploy your app on Aurora, you\u2019re partnering with a highly-capable and dedicated organization, and building upon a technical foundation that will scale to meet all your future needs.","title":"I'm an app developer. Why should I choose Aurora over other EVMs?"},{"location":"develop/faq.html#what-are-the-basic-performance-metrics","text":"Aurora is a major use case for the NEAR blockchain that requires many changes on different levels. At the moment we\u2019re waiting for NEAR validators to accept the protocol change that will add EVM precompiles. We expect this to happen in the first half of the summer. After this protocol upgrade one can expect Aurora to be able to host twice the throughput of the Ethereum Mainnet. There\u2019s still a lot of room for a single-shard Aurora improvement, so we expect further throughput increases.","title":"What are the basic performance metrics?"},{"location":"develop/faq.html#how-will-transaction-fees-work","text":"The base fee token of Aurora is ETH, which will make your users feel right at home. By leveraging the underlying low-cost capabilities of the NEAR Protocol, Aurora transactions will typically cost pennies. What\u2019s particularly interesting, is that the underlying fee model of NEAR opens the door to innovative possibilities, such as AuroraDAO directed mechanisms of channeling a portion of collected fees back to the projects running on Aurora!","title":"How will transaction fees work?"},{"location":"develop/faq.html#what-does-the-high-level-roadmap-look-like","text":"While the detailed Aurora roadmap is available on the web site , in general, over the course of summer we plan to optimise Aurora and take care of the DAO formation and token development (if this is decided by the DAO). In Autumn, we plan to deliver several major features, such as introduction of fast bridging of the most popular tokens, ability to pay fees in stable coins and simplified UX for non-blockchain users. We\u2019re planning to deliver a sharded version of Aurora early next year.","title":"What does the high-level roadmap look like?"},{"location":"develop/faq.html#how-do-i-get-started-with-aurora","text":"The Aurora EVM has been deployed on the NEAR Mainnet and Testnet networks. Asset connectors\u2014e.g. our \u201cETH Connector\u201d and \u201cERC-20 Connectors\u201d\u2014allow asset transfers between Aurora and Ethereum, using the Aurora Bridge. Currently, the ETH Connector is deployed and functional on Testnet, with the ERC-20 Connector soon to follow. In this way, project owners should be able to test their deployments on Aurora fully in May, followed by production deployments in June of 2021. For those interested in getting started, a set of Aurora Documents is currently available.","title":"How do I get started with Aurora?"},{"location":"develop/faq.html#how-will-bridging-tokens-between-ethereum-and-aurora-work","text":"Very easy! You'll select the direction of transfer, the token you want to transfer, and the amount. Your address on Aurora will be the same as your Ethereum address. The Aurora Bridge will initially work with MetaMask. To access your tokens and apps on Aurora, you\u2019ll need to add Aurora as an additional network to MetaMask, and the Bridge will help you with that.","title":"How will bridging tokens between Ethereum and Aurora work?"},{"location":"develop/faq.html#which-tokens-will-be-supported","text":"Initially, ETH\u2014the base fee token of Aurora\u2014will be supported, followed by a select list of popular ERC-20 tokens, and then any arbitrary assets. This rollout is planned to take place during May and June of 2021.","title":"Which tokens will be supported?"},{"location":"develop/faq.html#how-long-will-transfers-take","text":"To ensure security, transfers to Aurora take about 10 minutes, and transfers back to Ethereum take about a day. As you can see from our roadmap, we\u2019ll be dramatically improving those transfer times by Autumn of 2021.","title":"How long will transfers take?"},{"location":"develop/faq.html#why-will-transfers-take-so-long","text":"The Aurora Bridge technical architecture is designed to be \u201ctrustless\u201d, meaning there\u2019s no reliance on third-parties for authorizations. Trustless transfers align with the ethos of decentralized finance, but do require more time, given that network confirmations to ensure transaction finality. There are, however, technical ways in which we can, and will, shorten transfer times in future updates to the bridge.","title":"Why will transfers take so long?"},{"location":"develop/faq.html#will-i-be-able-to-initiate-multiple-transfers-in-parallel","text":"Yes! Since confirmation of transfer can take a while, you\u2019ll be able to initiate any number of concurrent transfers.","title":"Will I be able to initiate multiple transfers in parallel?"},{"location":"develop/faq.html#i-have-a-few-more-questions-where-can-i-get-help","text":"For support and help with any questions, don't hesitate to reach out on Telegram channels: official channel , support channel , development channel .","title":"I have a few more questions. Where can I get help?"},{"location":"develop/glossary.html","text":"Glossary \u00b6 0-9 \u00b6 A \u00b6 B \u00b6 C \u00b6 D \u00b6 E \u00b6 F \u00b6 G \u00b6 H \u00b6 I \u00b6 J \u00b6 K \u00b6 L \u00b6 M \u00b6 N \u00b6 O \u00b6 P \u00b6 PoS \u00b6 Proof of stake. PoW \u00b6 Proof of work. Q \u00b6 R \u00b6 S \u00b6 T \u00b6 U \u00b6 V \u00b6 W \u00b6 X \u00b6 Y \u00b6 Z \u00b6","title":"Glossary"},{"location":"develop/glossary.html#glossary","text":"","title":"Glossary"},{"location":"develop/glossary.html#0-9","text":"","title":"0-9"},{"location":"develop/glossary.html#a","text":"","title":"A"},{"location":"develop/glossary.html#b","text":"","title":"B"},{"location":"develop/glossary.html#c","text":"","title":"C"},{"location":"develop/glossary.html#d","text":"","title":"D"},{"location":"develop/glossary.html#e","text":"","title":"E"},{"location":"develop/glossary.html#f","text":"","title":"F"},{"location":"develop/glossary.html#g","text":"","title":"G"},{"location":"develop/glossary.html#h","text":"","title":"H"},{"location":"develop/glossary.html#i","text":"","title":"I"},{"location":"develop/glossary.html#j","text":"","title":"J"},{"location":"develop/glossary.html#k","text":"","title":"K"},{"location":"develop/glossary.html#l","text":"","title":"L"},{"location":"develop/glossary.html#m","text":"","title":"M"},{"location":"develop/glossary.html#n","text":"","title":"N"},{"location":"develop/glossary.html#o","text":"","title":"O"},{"location":"develop/glossary.html#p","text":"","title":"P"},{"location":"develop/glossary.html#pos","text":"Proof of stake.","title":"PoS"},{"location":"develop/glossary.html#pow","text":"Proof of work.","title":"PoW"},{"location":"develop/glossary.html#q","text":"","title":"Q"},{"location":"develop/glossary.html#r","text":"","title":"R"},{"location":"develop/glossary.html#s","text":"","title":"S"},{"location":"develop/glossary.html#t","text":"","title":"T"},{"location":"develop/glossary.html#u","text":"","title":"U"},{"location":"develop/glossary.html#v","text":"","title":"V"},{"location":"develop/glossary.html#w","text":"","title":"W"},{"location":"develop/glossary.html#x","text":"","title":"X"},{"location":"develop/glossary.html#y","text":"","title":"Y"},{"location":"develop/glossary.html#z","text":"","title":"Z"},{"location":"develop/networks.html","text":"Networks \u00b6 Ethereum Virtual Machine (EVM) support is currently available on the following networks: Network Engine ID Chain ID Endpoint URL Mainnet aurora 1313161554 (0x4e454152) https://mainnet.aurora.dev Testnet aurora 1313161555 (0x4e454153) https://testnet.aurora.dev Betanet aurora 1313161556 (0x4e454154) https://betanet.aurora.dev Localnet aurora.test.near 1313161556 (0x4e454154) http://localhost:8545 Find the status page and public incident log at api.aurora.dev . You can also subscribe to incident notifications there. Endpoints \u00b6 Mainnet \u00b6 The Mainnet Web3 endpoint is at: https://mainnet.aurora.dev (port 443) Testnet \u00b6 The Testnet Web3 endpoint is at: https://testnet.aurora.dev (port 443) Betanet \u00b6 The Betanet Web3 endpoint is at: https://betanet.aurora.dev (port 443)","title":"Networks"},{"location":"develop/networks.html#networks","text":"Ethereum Virtual Machine (EVM) support is currently available on the following networks: Network Engine ID Chain ID Endpoint URL Mainnet aurora 1313161554 (0x4e454152) https://mainnet.aurora.dev Testnet aurora 1313161555 (0x4e454153) https://testnet.aurora.dev Betanet aurora 1313161556 (0x4e454154) https://betanet.aurora.dev Localnet aurora.test.near 1313161556 (0x4e454154) http://localhost:8545 Find the status page and public incident log at api.aurora.dev . You can also subscribe to incident notifications there.","title":"Networks"},{"location":"develop/networks.html#endpoints","text":"","title":"Endpoints"},{"location":"develop/networks.html#mainnet","text":"The Mainnet Web3 endpoint is at: https://mainnet.aurora.dev (port 443)","title":"Mainnet"},{"location":"develop/networks.html#testnet","text":"The Testnet Web3 endpoint is at: https://testnet.aurora.dev (port 443)","title":"Testnet"},{"location":"develop/networks.html#betanet","text":"The Betanet Web3 endpoint is at: https://betanet.aurora.dev (port 443)","title":"Betanet"},{"location":"develop/roadmap.html","text":"Roadmap \u00b6 For the latest roadmap updates, see our posts in the Aurora forum or the roadmap section on Aurora website . Done \u2014 Deploy Aurora Engine to Mainnet, Testnet and Betanet May 2021 \u2014 Transfer ETH and ERC-20 tokens between Ethereum and Aurora May 2021 \u2014 Transfer the NEAR token between Ethereum and NEAR June 2021 \u2014 Completion of Aurora fund-raising campaign June 2021 \u2014 Filling of all AuroraDAO initial seats Autumn 2021 \u2014 Fast token transfer Autumn 2021 \u2014 Gas fees denominated in ERC-20s Autumn 2021 \u2014 Simplified \u201cHide the Blockchain\u201d UX","title":"Roadmap"},{"location":"develop/roadmap.html#roadmap","text":"For the latest roadmap updates, see our posts in the Aurora forum or the roadmap section on Aurora website . Done \u2014 Deploy Aurora Engine to Mainnet, Testnet and Betanet May 2021 \u2014 Transfer ETH and ERC-20 tokens between Ethereum and Aurora May 2021 \u2014 Transfer the NEAR token between Ethereum and NEAR June 2021 \u2014 Completion of Aurora fund-raising campaign June 2021 \u2014 Filling of all AuroraDAO initial seats Autumn 2021 \u2014 Fast token transfer Autumn 2021 \u2014 Gas fees denominated in ERC-20s Autumn 2021 \u2014 Simplified \u201cHide the Blockchain\u201d UX","title":"Roadmap"},{"location":"develop/compat/index.html","text":"Compatibility \u00b6","title":"Aurora: Compatibility"},{"location":"develop/compat/index.html#compatibility","text":"","title":"Compatibility"},{"location":"develop/compat/evm.html","text":"Compatibility with the Ethereum Virtual Machine (EVM) \u00b6 The Aurora Engine implements an Ethereum Virtual Machine (EVM) on top of the NEAR Protocol. Balances \u00b6 EVM address balances are denominated in ether (ETH) for compatibility with Ethereum. Gas \u00b6 See notes on gas . Precompiles \u00b6 Standard precompiles \u00b6 Address ID Name Spec Status 0x01 ECRecover ECDSA public key recovery Yellow Paper \u2705 0x02 SHA256 SHA-2 256-bit hash function Yellow Paper \u2705 0x03 RIPEMD160 RIPEMD 160-bit hash function Yellow Paper \u2705 0x04 Identity Identity function Yellow Paper \u2705 0x05 ModExp Big integer modular exponentation EIP-198 \u2705 0x06 BN128Add Elliptic curve addition EIP-196 \u2705 0x07 BN128Mul Elliptic curve scalar multiplication EIP-196 \u2705 0x08 BN128Pair Elliptic curve pairing check EIP-197 \u2705 0x09 Blake2F BLAKE2b F compression function EIP-152 \u2705 Opcodes \u00b6 BLOCKHASH \u00b6 This opcode currently does not return a real blockhash. However, it does respect the logic that a non-zero value is returned for the most recent 256 blocks (not including the current block). For all other inputs it returns zero. The non-zero value that is returned is 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff . For example, if the current block height is h , then BLOCKHASH(h) = 0x000... , BLOCKHASH(h - 100) = 0xfff... and BLOCKHASH(h - 257) = 0x000.. . This behavior may change in the future, see nearcore#4256 to track this issue. COINBASE \u00b6 This opcode returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b . DIFFICULTY \u00b6 This opcode always returns zero, since NEAR is not a proof-of-work (PoW) network. GASLIMIT \u00b6 This opcode always returns 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff (2^256-1). Limitations \u00b6 The Berlin hard fork is not yet supported. The EVM currently supports the feature set of the Istanbul hard fork. The BLOCKHASH opcode currently always returns either 0xfff... (if the input is within 256 blocks) or 0x000... (for the current height or one more than 256 blocks in the past). Source Code \u00b6 The Aurora Engine source code repository is at: github.com/aurora-is-near/aurora-engine .","title":"EVM"},{"location":"develop/compat/evm.html#compatibility-with-the-ethereum-virtual-machine-evm","text":"The Aurora Engine implements an Ethereum Virtual Machine (EVM) on top of the NEAR Protocol.","title":"Compatibility with the Ethereum Virtual Machine (EVM)"},{"location":"develop/compat/evm.html#balances","text":"EVM address balances are denominated in ether (ETH) for compatibility with Ethereum.","title":"Balances"},{"location":"develop/compat/evm.html#gas","text":"See notes on gas .","title":"Gas"},{"location":"develop/compat/evm.html#precompiles","text":"","title":"Precompiles"},{"location":"develop/compat/evm.html#standard-precompiles","text":"Address ID Name Spec Status 0x01 ECRecover ECDSA public key recovery Yellow Paper \u2705 0x02 SHA256 SHA-2 256-bit hash function Yellow Paper \u2705 0x03 RIPEMD160 RIPEMD 160-bit hash function Yellow Paper \u2705 0x04 Identity Identity function Yellow Paper \u2705 0x05 ModExp Big integer modular exponentation EIP-198 \u2705 0x06 BN128Add Elliptic curve addition EIP-196 \u2705 0x07 BN128Mul Elliptic curve scalar multiplication EIP-196 \u2705 0x08 BN128Pair Elliptic curve pairing check EIP-197 \u2705 0x09 Blake2F BLAKE2b F compression function EIP-152 \u2705","title":"Standard precompiles"},{"location":"develop/compat/evm.html#opcodes","text":"","title":"Opcodes"},{"location":"develop/compat/evm.html#blockhash","text":"This opcode currently does not return a real blockhash. However, it does respect the logic that a non-zero value is returned for the most recent 256 blocks (not including the current block). For all other inputs it returns zero. The non-zero value that is returned is 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff . For example, if the current block height is h , then BLOCKHASH(h) = 0x000... , BLOCKHASH(h - 100) = 0xfff... and BLOCKHASH(h - 257) = 0x000.. . This behavior may change in the future, see nearcore#4256 to track this issue.","title":"BLOCKHASH"},{"location":"develop/compat/evm.html#coinbase","text":"This opcode returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b .","title":"COINBASE"},{"location":"develop/compat/evm.html#difficulty","text":"This opcode always returns zero, since NEAR is not a proof-of-work (PoW) network.","title":"DIFFICULTY"},{"location":"develop/compat/evm.html#gaslimit","text":"This opcode always returns 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff (2^256-1).","title":"GASLIMIT"},{"location":"develop/compat/evm.html#limitations","text":"The Berlin hard fork is not yet supported. The EVM currently supports the feature set of the Istanbul hard fork. The BLOCKHASH opcode currently always returns either 0xfff... (if the input is within 256 blocks) or 0x000... (for the current height or one more than 256 blocks in the past).","title":"Limitations"},{"location":"develop/compat/evm.html#source-code","text":"The Aurora Engine source code repository is at: github.com/aurora-is-near/aurora-engine .","title":"Source Code"},{"location":"develop/compat/gas.html","text":"Notes on Gas \u00b6 Aurora runs on top of NEAR, so in some sense NEAR gas is the real measure of computational work. However, for compatibility with Ethereum we want our users to be able to pay for transactions with ether (ETH). To enable this, the Aurora infrastructure includes relayers which encapsulate ordinary EVM transactions into NEAR transactions, submit them on-chain, and return the transaction result. In the future, these relayers will charge ETH to the address that sent the transaction based on the amount of NEAR that was spent on the NEAR gas to complete the transaction. However, in this early-release phase, this logic is not implemented and therefore no ETH is actually charged for the gas spent. The main takeaway from this discussion is to set the gas price of Aurora transactions to zero for the time being . Gas limits \u00b6 Even though no ETH is charged, Aurora still respects gas limits. That is to say, even with a gas price of zero, if a transaction spends more gas than its limit, it will fail with an out of gas error. Therefore, developers must still consider what the gas limit of a transaction should be even when the gas price is zero. The amount of EVM gas spent by a transaction is computed using the standard Ethereum rules. Therefore, developers can still estimate the cost of transactions as if it were running on any other EVM-compatible network. Compatibility limitations \u00b6 Since the underlying measure of computational work is NEAR gas, an edge case that arises is when the transaction runs out of NEAR gas before running out of EVM gas. In this case the transaction will be considered as failed on Aurora, but this may or may not be compatible with what the outcome on Ethereum would have been (if the gas limit was actually high enough for the transaction to complete had NEAR gas not been the limiting factor). This case will not come up for the vast majority of transactions, and indeed will become less and less likely as we improve the efficiency of our EVM contract (thus allowing NEAR gas to go further in terms of EVM computation). Eventually we hope to eliminate this entirely by setting the ETH block gas limit on Aurora to be lower than the amount of NEAR which we could spend in one transaction.","title":"Gas"},{"location":"develop/compat/gas.html#notes-on-gas","text":"Aurora runs on top of NEAR, so in some sense NEAR gas is the real measure of computational work. However, for compatibility with Ethereum we want our users to be able to pay for transactions with ether (ETH). To enable this, the Aurora infrastructure includes relayers which encapsulate ordinary EVM transactions into NEAR transactions, submit them on-chain, and return the transaction result. In the future, these relayers will charge ETH to the address that sent the transaction based on the amount of NEAR that was spent on the NEAR gas to complete the transaction. However, in this early-release phase, this logic is not implemented and therefore no ETH is actually charged for the gas spent. The main takeaway from this discussion is to set the gas price of Aurora transactions to zero for the time being .","title":"Notes on Gas"},{"location":"develop/compat/gas.html#gas-limits","text":"Even though no ETH is charged, Aurora still respects gas limits. That is to say, even with a gas price of zero, if a transaction spends more gas than its limit, it will fail with an out of gas error. Therefore, developers must still consider what the gas limit of a transaction should be even when the gas price is zero. The amount of EVM gas spent by a transaction is computed using the standard Ethereum rules. Therefore, developers can still estimate the cost of transactions as if it were running on any other EVM-compatible network.","title":"Gas limits"},{"location":"develop/compat/gas.html#compatibility-limitations","text":"Since the underlying measure of computational work is NEAR gas, an edge case that arises is when the transaction runs out of NEAR gas before running out of EVM gas. In this case the transaction will be considered as failed on Aurora, but this may or may not be compatible with what the outcome on Ethereum would have been (if the gas limit was actually high enough for the transaction to complete had NEAR gas not been the limiting factor). This case will not come up for the vast majority of transactions, and indeed will become less and less likely as we improve the efficiency of our EVM contract (thus allowing NEAR gas to go further in terms of EVM computation). Eventually we hope to eliminate this entirely by setting the ETH block gas limit on Aurora to be lower than the amount of NEAR which we could spend in one transaction.","title":"Compatibility limitations"},{"location":"develop/compat/rpc.html","text":"Compatibility with the Web3 JSON-RPC Protocol \u00b6 The Aurora Relayer implements the Web3 JSON-RPC protocol. Methods \u00b6 Method Status Notes web3_clientVersion \u2705 web3_sha3 \u2705 net_listening \u2705 net_peerCount \u2705 net_version \u2705 eth_accounts \u2705 eth_blockNumber \u2705 eth_call \ud83d\udea7 eth_chainId \u2705 eth_coinbase \u2705 eth_compileLLL \u274c Unsupported eth_compileSerpent \u274c Unsupported eth_compileSolidity \u274c Unsupported eth_estimateGas \u2705 eth_gasPrice \u2705 eth_getBalance \u2705 eth_getBlockByHash \u2705 eth_getBlockByNumber \u2705 eth_getBlockTransactionCountByHash \u2705 eth_getBlockTransactionCountByNumber \u2705 eth_getCode \u2705 eth_getCompilers \u2705 eth_getFilterChanges \ud83d\udea7 eth_getFilterLogs \ud83d\udea7 eth_getLogs \ud83d\udea7 eth_getProof \u274c EIP-1186 eth_getStorageAt \u2705 eth_getTransactionByBlockHashAndIndex \u2705 eth_getTransactionByBlockNumberAndIndex \u2705 eth_getTransactionByHash \ud83d\udea7 eth_getTransactionCount \u2705 eth_getTransactionReceipt \ud83d\udea7 eth_getUncleByBlockHashAndIndex \u2705 eth_getUncleByBlockNumberAndIndex \u2705 eth_getUncleCountByBlockHash \u2705 eth_getUncleCountByBlockNumber \u2705 eth_getWork \u274c Unsupported eth_hashrate \u2705 eth_mining \u2705 eth_newBlockFilter \ud83d\udea7 eth_newFilter \ud83d\udea7 eth_newPendingTransactionFilter \ud83d\udea7 eth_pendingTransactions \u2705 Undocumented eth_protocolVersion \u2705 eth_sendRawTransaction \ud83d\udea7 eth_sendTransaction \ud83d\udea7 eth_sign \ud83d\udea7 eth_signTransaction \ud83d\udea7 eth_signTypedData \ud83d\udea7 EIP-712 eth_submitHashrate \u274c Unsupported eth_submitWork \u274c Unsupported eth_syncing \u2705 eth_uninstallFilter \ud83d\udea7 db_getHex \u274c Deprecated db_getString \u274c Deprecated db_putHex \u274c Deprecated db_putString \u274c Deprecated shh_addToGroup \u274c Discontinued shh_getFilterChanges \u274c Discontinued shh_getMessages \u274c Discontinued shh_hasIdentity \u274c Discontinued shh_newFilter \u274c Discontinued shh_newGroup \u274c Discontinued shh_newIdentity \u274c Discontinued shh_post \u274c Discontinued shh_uninstallFilter \u274c Discontinued shh_version \u274c Discontinued Legend : \u274c = not supported. \ud83d\udea7 = work in progress. \u2705 = supported. Limitations \u00b6 The eth_getProof method ( EIP-1186 ) is not supported and is unlikely to be possible to implement. Notes \u00b6 For now, the eth_estimateGas method returns a fixed value (6,721,975, matching Truffle's default gas limit), since no gas is charged . Ethereum is a proof-of-work (PoW) network, and NEAR is a proof-of-stake (PoS) network. Therefore with Aurora all mining-related methods such as eth_getWork , eth_submitHashrate , and eth_submitWork are not supported and return an error code. Additionally, PoW-related block metadata such as nonce and difficulty contain all zeroes. The eth_coinbase method returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b . There is no concept of uncle (aka ommer) blocks. The eth_getUncleByBlockHashAndIndex and eth_getUncleByBlockNumberAndIndex methods always return null . The eth_getUncleCountByBlockHash and eth_getUncleCountByBlockNumber methods return zero for valid block IDs and null for invalid block IDs. Additionally, uncle-related block metadata such as sha3Uncles contain all zeroes. There is no access to pending transactions. The eth_newPendingTransactionFilter method creates a filter that returns nothing when polled with eth_getFilterChanges . The nonstandard Geth tracing APIs are not supported at present, but we do have plans to implement them going forward. ( #12 ) The nonstandard Parity tracing APIs are not supported at present, but we do have plans to implement them going forward. ( #13 ) Source Code \u00b6 The Aurora Relayer source code repository is at: github.com/aurora-is-near/aurora-relayer .","title":"JSON-RPC"},{"location":"develop/compat/rpc.html#compatibility-with-the-web3-json-rpc-protocol","text":"The Aurora Relayer implements the Web3 JSON-RPC protocol.","title":"Compatibility with the Web3 JSON-RPC Protocol"},{"location":"develop/compat/rpc.html#methods","text":"Method Status Notes web3_clientVersion \u2705 web3_sha3 \u2705 net_listening \u2705 net_peerCount \u2705 net_version \u2705 eth_accounts \u2705 eth_blockNumber \u2705 eth_call \ud83d\udea7 eth_chainId \u2705 eth_coinbase \u2705 eth_compileLLL \u274c Unsupported eth_compileSerpent \u274c Unsupported eth_compileSolidity \u274c Unsupported eth_estimateGas \u2705 eth_gasPrice \u2705 eth_getBalance \u2705 eth_getBlockByHash \u2705 eth_getBlockByNumber \u2705 eth_getBlockTransactionCountByHash \u2705 eth_getBlockTransactionCountByNumber \u2705 eth_getCode \u2705 eth_getCompilers \u2705 eth_getFilterChanges \ud83d\udea7 eth_getFilterLogs \ud83d\udea7 eth_getLogs \ud83d\udea7 eth_getProof \u274c EIP-1186 eth_getStorageAt \u2705 eth_getTransactionByBlockHashAndIndex \u2705 eth_getTransactionByBlockNumberAndIndex \u2705 eth_getTransactionByHash \ud83d\udea7 eth_getTransactionCount \u2705 eth_getTransactionReceipt \ud83d\udea7 eth_getUncleByBlockHashAndIndex \u2705 eth_getUncleByBlockNumberAndIndex \u2705 eth_getUncleCountByBlockHash \u2705 eth_getUncleCountByBlockNumber \u2705 eth_getWork \u274c Unsupported eth_hashrate \u2705 eth_mining \u2705 eth_newBlockFilter \ud83d\udea7 eth_newFilter \ud83d\udea7 eth_newPendingTransactionFilter \ud83d\udea7 eth_pendingTransactions \u2705 Undocumented eth_protocolVersion \u2705 eth_sendRawTransaction \ud83d\udea7 eth_sendTransaction \ud83d\udea7 eth_sign \ud83d\udea7 eth_signTransaction \ud83d\udea7 eth_signTypedData \ud83d\udea7 EIP-712 eth_submitHashrate \u274c Unsupported eth_submitWork \u274c Unsupported eth_syncing \u2705 eth_uninstallFilter \ud83d\udea7 db_getHex \u274c Deprecated db_getString \u274c Deprecated db_putHex \u274c Deprecated db_putString \u274c Deprecated shh_addToGroup \u274c Discontinued shh_getFilterChanges \u274c Discontinued shh_getMessages \u274c Discontinued shh_hasIdentity \u274c Discontinued shh_newFilter \u274c Discontinued shh_newGroup \u274c Discontinued shh_newIdentity \u274c Discontinued shh_post \u274c Discontinued shh_uninstallFilter \u274c Discontinued shh_version \u274c Discontinued Legend : \u274c = not supported. \ud83d\udea7 = work in progress. \u2705 = supported.","title":"Methods"},{"location":"develop/compat/rpc.html#limitations","text":"The eth_getProof method ( EIP-1186 ) is not supported and is unlikely to be possible to implement.","title":"Limitations"},{"location":"develop/compat/rpc.html#notes","text":"For now, the eth_estimateGas method returns a fixed value (6,721,975, matching Truffle's default gas limit), since no gas is charged . Ethereum is a proof-of-work (PoW) network, and NEAR is a proof-of-stake (PoS) network. Therefore with Aurora all mining-related methods such as eth_getWork , eth_submitHashrate , and eth_submitWork are not supported and return an error code. Additionally, PoW-related block metadata such as nonce and difficulty contain all zeroes. The eth_coinbase method returns the EVM address of the Aurora Engine. For example, for the Aurora Engine deployment on the aurora account, COINBASE returns 0x4444588443C3a91288c5002483449Aba1054192b . There is no concept of uncle (aka ommer) blocks. The eth_getUncleByBlockHashAndIndex and eth_getUncleByBlockNumberAndIndex methods always return null . The eth_getUncleCountByBlockHash and eth_getUncleCountByBlockNumber methods return zero for valid block IDs and null for invalid block IDs. Additionally, uncle-related block metadata such as sha3Uncles contain all zeroes. There is no access to pending transactions. The eth_newPendingTransactionFilter method creates a filter that returns nothing when polled with eth_getFilterChanges . The nonstandard Geth tracing APIs are not supported at present, but we do have plans to implement them going forward. ( #12 ) The nonstandard Parity tracing APIs are not supported at present, but we do have plans to implement them going forward. ( #13 )","title":"Notes"},{"location":"develop/compat/rpc.html#source-code","text":"The Aurora Relayer source code repository is at: github.com/aurora-is-near/aurora-relayer .","title":"Source Code"},{"location":"develop/start/index.html","text":"Getting Started \u00b6","title":"Aurora: Getting Started"},{"location":"develop/start/index.html#getting-started","text":"","title":"Getting Started"},{"location":"develop/start/hardhat.html","text":"Getting Started with Hardhat \u00b6 Introduction \u00b6 Hardhat is yet another Ethereum development environment. It is known for debugging the Solidity code and the explicit error messages. Moreover it has extra nice features such as the interactive JavaScript console and the user defined tasks. The main objective of this tutorial is to show how to deploy and interact with the Solidity smart contracts on Aurora using Hardhat. This tutorial assumes that you are familiar with Hardhat and the ERC-20 tokens. For more details about the fungible token standard, please refer to the ERC-20 Standard specification . Installation \u00b6 This tutorial assumes that you have Node.js 12+ and Yarn. Please refer to the Yarn installation how-to if you don't yet have the yarn command installed locally. To install the prerequisite packages, clone the examples repository: git clone https://github.com/aurora-is-near/aurora-examples.git cd aurora-examples/hardhat/erc20/ Add your Aurora Private key (from MetaMask) to .env file and then run yarn : echo \"AURORA_PRIVATE_KEY=YOUR_AURORA_PRIVATE_KEY_HERE\" >> .env yarn install Deploy ERC-20 \u00b6 The ERC-20 example is about a naive Watermelon token \ud83c\udf49. You can exchange them into actual Watermelons \ud83c\udf49\ud83c\udf49\ud83c\udf49. The total supply is 1000000 , the minter is the contract deployer address, and the decimals are 0 (One token \u2192 One watermelon). To deploy the ERC-20 token contract, use the following command: $ make deploy NETWORK = testnet_aurora yarn hardat run scripts/deploy.js --network testnet_aurora yarn run v1.22.10 Deploying contracts with the account: 0x6A33382de9f73B846878a57500d055B981229ac4 Account balance: 2210010200000000000 WatermelonToken deployed to: 0xD7f2A76F5DA173043E6c61a0A18D835809A07766 \u2728 Done in 14 .96s. # export the token address $ export TOKEN_ADDRESS = 'YOUR OUTPUT FROM DEPLOY (e.g. 0xD7f2A76F5DA173043E6c61a0A18D835809A07766)' Hardhat Tasks \u00b6 Hardhat tasks take care of parsing the values provided for each parameter. It gets the values, performs the type validation and converts them into your desired type. In this example, we will go through a set of pre-defined Hardhat tasks that uses the Hardhat Runtime Environment ( HRE ). In order to complete the tutorial, you should use them in the same order: ETH Balance \u00b6 The following Hardhat task uses the Web3 plugin to get the account\u2019s balance: task ( \"balance\" , \"Prints an account's balance\" ) . addParam ( \"account\" , \"The account's address\" ) . setAction ( async taskArgs => { const account = web3 . utils . toChecksumAddress ( taskArgs . account ); const balance = await web3 . eth . getBalance ( account ); console . log ( web3 . utils . fromWei ( balance , \"ether\" ), \"ETH\" ); }); To get the ETH balance, use the following command: npx hardhat balance --network testnet_aurora --account 0x6A33382de9f73B846878a57500d055B981229ac4 2 .2100102 ETH You should notice that --network is a global built-in option (parameter) in Hardhat. We will use it for the following commands as well. Total Supply \u00b6 The following task script gets the total supply of the Watermelon ERC-20 token. First it attachs the token contract, gets the sender address and finally retrieves the total supply by calling totalSupply() method in our ERC-20 contract. The --token address is the ERC-20 contract address. task ( \"totalSupply\" , \"Total supply of ERC-20 token\" ) . addParam ( \"token\" , \"Token address\" ) . setAction ( async function ({ token }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ minter ] = await ethers . getSigners (); const totalSupply = ( await ( await watermelon . connect ( minter )). totalSupply ()). toNumber () console . log ( `Total Supply is ${ totalSupply } ` ); }); To get the totalSupply , use the following command: $ npx hardhat totalSupply --token $TOKEN_ADDRESS --network testnet_aurora Total Supply is 1000000 Transfer ERC-20 \u00b6 The transfer option allows anyone holding an ERC-20 tokens to transfer them to any Ethereum address. In the following script, the minter address will mint (implicitly) and transfer 10 WTM tokens to the spender address: task ( \"transfer\" , \"ERC-20 transfer\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"spender\" , \"Spender address\" ) . addParam ( \"amount\" , \"Token amount\" ) . setAction ( async function ({ token , spender , amount }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ minter ] = await ethers . getSigners (); await ( await watermelon . connect ( minter ). transfer ( spender , amount )). wait () console . log ( ` ${ minter . address } has transferred ${ amount } to ${ spender } ` ); }); To call transfer , use the following command: $ npx hardhat transfer --token $TOKEN_ADDRESS --amount 10 --spender 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe --network testnet_aurora 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 has transferred 10 tokens to 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe BalanceOf ERC-20 \u00b6 We can prove that the spender has received the exact amount of tokens by calling the balanceOf as shown below: task ( \"balanceOf\" , \"Total supply of ERC-20 token\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"account\" , \"Account address\" ) . setAction ( async function ({ token , account }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ minter ] = await ethers . getSigners (); const balance = ( await ( await watermelon . connect ( minter )). balanceOf ( account )). toNumber () console . log ( `Account ${ account } has a total token balance: ${ balance } WTM` ); }); To get the balance , use the following command: $ npx hardhat balanceOf --token $TOKEN_ADDRESS --account 0x6A33382de9f73B846878a57500d055B981229ac4 --network testnet_aurora Account 0x6A33382de9f73B846878a57500d055B981229ac4 has a total token balance: 999970 WTM Approve ERC-20 \u00b6 In some cases, instead of calling the transfer directly, the sender can approve a specific amount of tokens to be withdrawn from his account to specific receipient address later. This can be done by calling approve then calling transferFrom . task ( \"approve\" , \"ERC-20 approve\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"spender\" , \"Spender address\" ) . addParam ( \"amount\" , \"Token amount\" ) . setAction ( async function ({ token , spender , amount }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ sender ] = await ethers . getSigners (); await ( await watermelon . connect ( sender ). approve ( spender , amount )). wait () console . log ( ` ${ sender . address } has approved ${ amount } tokens to ${ spender } ` ); }); module . exports = {}; To call approve , use the following command: npx hardhat approve --token $TOKEN_ADDRESS --spender 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 --amount 10 --network testnet_aurora 0x6A33382de9f73B846878a57500d055B981229ac4 has approved 10 tokens to 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 TransferFrom ERC-20 \u00b6 After approving the tokens, a receipient can call transferFrom to move the allowance to his account. task ( \"transferFrom\" , \"ERC-20 transferFrom\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"sender\" , \"Sender address\" ) . addParam ( \"amount\" , \"Token amount\" ) . setAction ( async function ({ token , sender , amount }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ recipient ] = await ethers . getSigners () console . log ( recipient . address ); await ( await watermelon . connect ( recipient ). transferFrom ( sender , recipient . address , amount )). wait () console . log ( ` ${ recipient . address } has received ${ amount } tokens from ${ sender } ` ) }); To call transferFrom , use the following command: # export the recipient private key AURORA_PRIVATE_KEY = \"THE RECIPIENT PRIVATE KEY\" npx hardhat transferFrom --token $TOKEN_ADDRESS --sender 0x6A33382de9f73B846878a57500d055B981229ac4 --amount 10 --network testnet_aurora 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 has received 10 tokens from 0x6A33382de9f73B846878a57500d055B981229ac4 Checking the balance of 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 : npx hardhat balanceOf --token $TOKEN_ADDRESS --account 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 --network testnet_aurora Account 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 has a total token balance: 10 WTM Conclusion \u00b6 In this tutorial we deployed an ERC-20 token using Hardhat on the Aurora Testnet, transferred, and approved ERC-20 tokens. Moreover, we added other utility tasks such as getting the total supply, and the account balance. The only difference is we changed the Ethereum Mainnet to the Aurora RPC endpoint.","title":"Hardhat"},{"location":"develop/start/hardhat.html#getting-started-with-hardhat","text":"","title":"Getting Started with Hardhat"},{"location":"develop/start/hardhat.html#introduction","text":"Hardhat is yet another Ethereum development environment. It is known for debugging the Solidity code and the explicit error messages. Moreover it has extra nice features such as the interactive JavaScript console and the user defined tasks. The main objective of this tutorial is to show how to deploy and interact with the Solidity smart contracts on Aurora using Hardhat. This tutorial assumes that you are familiar with Hardhat and the ERC-20 tokens. For more details about the fungible token standard, please refer to the ERC-20 Standard specification .","title":"Introduction"},{"location":"develop/start/hardhat.html#installation","text":"This tutorial assumes that you have Node.js 12+ and Yarn. Please refer to the Yarn installation how-to if you don't yet have the yarn command installed locally. To install the prerequisite packages, clone the examples repository: git clone https://github.com/aurora-is-near/aurora-examples.git cd aurora-examples/hardhat/erc20/ Add your Aurora Private key (from MetaMask) to .env file and then run yarn : echo \"AURORA_PRIVATE_KEY=YOUR_AURORA_PRIVATE_KEY_HERE\" >> .env yarn install","title":"Installation"},{"location":"develop/start/hardhat.html#deploy-erc-20","text":"The ERC-20 example is about a naive Watermelon token \ud83c\udf49. You can exchange them into actual Watermelons \ud83c\udf49\ud83c\udf49\ud83c\udf49. The total supply is 1000000 , the minter is the contract deployer address, and the decimals are 0 (One token \u2192 One watermelon). To deploy the ERC-20 token contract, use the following command: $ make deploy NETWORK = testnet_aurora yarn hardat run scripts/deploy.js --network testnet_aurora yarn run v1.22.10 Deploying contracts with the account: 0x6A33382de9f73B846878a57500d055B981229ac4 Account balance: 2210010200000000000 WatermelonToken deployed to: 0xD7f2A76F5DA173043E6c61a0A18D835809A07766 \u2728 Done in 14 .96s. # export the token address $ export TOKEN_ADDRESS = 'YOUR OUTPUT FROM DEPLOY (e.g. 0xD7f2A76F5DA173043E6c61a0A18D835809A07766)'","title":"Deploy ERC-20"},{"location":"develop/start/hardhat.html#hardhat-tasks","text":"Hardhat tasks take care of parsing the values provided for each parameter. It gets the values, performs the type validation and converts them into your desired type. In this example, we will go through a set of pre-defined Hardhat tasks that uses the Hardhat Runtime Environment ( HRE ). In order to complete the tutorial, you should use them in the same order:","title":"Hardhat Tasks"},{"location":"develop/start/hardhat.html#eth-balance","text":"The following Hardhat task uses the Web3 plugin to get the account\u2019s balance: task ( \"balance\" , \"Prints an account's balance\" ) . addParam ( \"account\" , \"The account's address\" ) . setAction ( async taskArgs => { const account = web3 . utils . toChecksumAddress ( taskArgs . account ); const balance = await web3 . eth . getBalance ( account ); console . log ( web3 . utils . fromWei ( balance , \"ether\" ), \"ETH\" ); }); To get the ETH balance, use the following command: npx hardhat balance --network testnet_aurora --account 0x6A33382de9f73B846878a57500d055B981229ac4 2 .2100102 ETH You should notice that --network is a global built-in option (parameter) in Hardhat. We will use it for the following commands as well.","title":"ETH Balance"},{"location":"develop/start/hardhat.html#total-supply","text":"The following task script gets the total supply of the Watermelon ERC-20 token. First it attachs the token contract, gets the sender address and finally retrieves the total supply by calling totalSupply() method in our ERC-20 contract. The --token address is the ERC-20 contract address. task ( \"totalSupply\" , \"Total supply of ERC-20 token\" ) . addParam ( \"token\" , \"Token address\" ) . setAction ( async function ({ token }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ minter ] = await ethers . getSigners (); const totalSupply = ( await ( await watermelon . connect ( minter )). totalSupply ()). toNumber () console . log ( `Total Supply is ${ totalSupply } ` ); }); To get the totalSupply , use the following command: $ npx hardhat totalSupply --token $TOKEN_ADDRESS --network testnet_aurora Total Supply is 1000000","title":"Total Supply"},{"location":"develop/start/hardhat.html#transfer-erc-20","text":"The transfer option allows anyone holding an ERC-20 tokens to transfer them to any Ethereum address. In the following script, the minter address will mint (implicitly) and transfer 10 WTM tokens to the spender address: task ( \"transfer\" , \"ERC-20 transfer\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"spender\" , \"Spender address\" ) . addParam ( \"amount\" , \"Token amount\" ) . setAction ( async function ({ token , spender , amount }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ minter ] = await ethers . getSigners (); await ( await watermelon . connect ( minter ). transfer ( spender , amount )). wait () console . log ( ` ${ minter . address } has transferred ${ amount } to ${ spender } ` ); }); To call transfer , use the following command: $ npx hardhat transfer --token $TOKEN_ADDRESS --amount 10 --spender 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe --network testnet_aurora 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 has transferred 10 tokens to 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe","title":"Transfer ERC-20"},{"location":"develop/start/hardhat.html#balanceof-erc-20","text":"We can prove that the spender has received the exact amount of tokens by calling the balanceOf as shown below: task ( \"balanceOf\" , \"Total supply of ERC-20 token\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"account\" , \"Account address\" ) . setAction ( async function ({ token , account }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ minter ] = await ethers . getSigners (); const balance = ( await ( await watermelon . connect ( minter )). balanceOf ( account )). toNumber () console . log ( `Account ${ account } has a total token balance: ${ balance } WTM` ); }); To get the balance , use the following command: $ npx hardhat balanceOf --token $TOKEN_ADDRESS --account 0x6A33382de9f73B846878a57500d055B981229ac4 --network testnet_aurora Account 0x6A33382de9f73B846878a57500d055B981229ac4 has a total token balance: 999970 WTM","title":"BalanceOf ERC-20"},{"location":"develop/start/hardhat.html#approve-erc-20","text":"In some cases, instead of calling the transfer directly, the sender can approve a specific amount of tokens to be withdrawn from his account to specific receipient address later. This can be done by calling approve then calling transferFrom . task ( \"approve\" , \"ERC-20 approve\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"spender\" , \"Spender address\" ) . addParam ( \"amount\" , \"Token amount\" ) . setAction ( async function ({ token , spender , amount }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ sender ] = await ethers . getSigners (); await ( await watermelon . connect ( sender ). approve ( spender , amount )). wait () console . log ( ` ${ sender . address } has approved ${ amount } tokens to ${ spender } ` ); }); module . exports = {}; To call approve , use the following command: npx hardhat approve --token $TOKEN_ADDRESS --spender 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 --amount 10 --network testnet_aurora 0x6A33382de9f73B846878a57500d055B981229ac4 has approved 10 tokens to 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771","title":"Approve ERC-20"},{"location":"develop/start/hardhat.html#transferfrom-erc-20","text":"After approving the tokens, a receipient can call transferFrom to move the allowance to his account. task ( \"transferFrom\" , \"ERC-20 transferFrom\" ) . addParam ( \"token\" , \"Token address\" ) . addParam ( \"sender\" , \"Sender address\" ) . addParam ( \"amount\" , \"Token amount\" ) . setAction ( async function ({ token , sender , amount }, { ethers : { getSigners } }, runSuper ) { const watermelonToken = await ethers . getContractFactory ( \"WatermelonToken\" ) const watermelon = watermelonToken . attach ( token ) const [ recipient ] = await ethers . getSigners () console . log ( recipient . address ); await ( await watermelon . connect ( recipient ). transferFrom ( sender , recipient . address , amount )). wait () console . log ( ` ${ recipient . address } has received ${ amount } tokens from ${ sender } ` ) }); To call transferFrom , use the following command: # export the recipient private key AURORA_PRIVATE_KEY = \"THE RECIPIENT PRIVATE KEY\" npx hardhat transferFrom --token $TOKEN_ADDRESS --sender 0x6A33382de9f73B846878a57500d055B981229ac4 --amount 10 --network testnet_aurora 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 has received 10 tokens from 0x6A33382de9f73B846878a57500d055B981229ac4 Checking the balance of 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 : npx hardhat balanceOf --token $TOKEN_ADDRESS --account 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 --network testnet_aurora Account 0x8722C88e82AbCC639148Ab6128Cd63333B2Ad771 has a total token balance: 10 WTM","title":"TransferFrom ERC-20"},{"location":"develop/start/hardhat.html#conclusion","text":"In this tutorial we deployed an ERC-20 token using Hardhat on the Aurora Testnet, transferred, and approved ERC-20 tokens. Moreover, we added other utility tasks such as getting the total supply, and the account balance. The only difference is we changed the Ethereum Mainnet to the Aurora RPC endpoint.","title":"Conclusion"},{"location":"develop/start/metamask.html","text":"Getting Started with MetaMask \u00b6 Introduction \u00b6 MetaMask is a convenient UI for interacting with Ethereum-compatible blockchains (such as Aurora). For the purpose of this guide, we will assume you are already familiar with MetaMask and have it installed. If you need help getting started with MetaMask itself, check out their documentation . In this tutorial we will walk through connecting MetaMask to the Aurora Testnet, deploying a simple ERC-20 contract using Remix , and transferring the new token using MetaMask. Note Screenshots in this tutorial are taken from the MetaMask browser extension version 9.5.5. Connecting MetaMask to Aurora \u00b6 In the top-right corner of the MetaMask interface, click the network selection drop-down and then click Custom RPC . Fill in the form with the following information: Network Name: Aurora Testnet New RPC URL: https://testnet.aurora.dev/ Chain ID: 1313161555 Currency Symbol: ETH Note All the Aurora RPC endpoint URLs and chain IDs can be found on our Networks page. Click Save , and you should see Aurora Testnet is now the network selected in MetaMask. To see MetaMask in action, we will connect it to Remix and perform some transactions. Deploying an ERC-20 Token using Remix \u00b6 In a new tab, open the Remix IDE at remix.ethereum.org . It might take a minute to load, but once it has, create a new file ERC20Token.sol in the workspace panel on the left: Copy and paste the following code into the central editor panel: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/ERC20.sol\" ; contract MyToken is ERC20 { constructor ( string memory name , string memory symbol ) ERC20 ( name , symbol ) { // Mint 100 tokens to msg.sender // Similar to how // 1 dollar = 100 cents // 1 token = 1 * (10 ** decimals) _mint ( msg.sender , 100 * 10 ** uint ( decimals ())); } } This code is a slightly modified (the Solidity compiler and OpenZeppelin versions are newer) version of the example from Solidity by Example . Click the Solidity Compile button on the far left panel (the second icon down); ensure your selected Solidity compiler version is 0.8 (minor versions within 0.8, e.g., 0.8.4 work too), and click Compile ERC20Token.sol . Once the contract is compiled, click the Deploy & run transactions button in the far left panel (the icon below the Solidity compiler). In the ENVIRONMENT drop-down select Injected Web3 . You will see a MetaMask pop-up window asking you to give the Remix IDE permission to access it. Click Next and then Connect to grant access. Back in the Remix interface, click the arrow next to the DEPLOY section of the left panel. Fill in the token details with whatever you like ( MyToken and MT in the example), and click transact . Another MetaMask pop-up will appear asking you to confirm the transaction. Click Confirm . Note You may be surprised to see the gas price set to zero in this transaction. During the early access period Aurora transactions are free, however this will change in the future. Not to worry, even when transaction fees will be non-zero, they'll still be much lower than on the Ethereum 1.0 Mainnet. After a few moments the transaction will be confirmed by the network. You will see a success message in the bottom panel and the contract listed under Deployed Contracts on the left panel. Click the copy button to copy the address of the newly deployed contract. Now that the contract is deployed on the Aurora network, we can interact with it via MetaMask. Adding an ERC-20 Token to MetaMask \u00b6 In the MetaMask interface (with the Aurora Testnet network still selected), click the Add Token button: Paste the token address copied from Remix in the previous step. The remaining token details should fill in automatically as MetaMask finds the contract on-chain. Click Next : On the next screen you see the balance (100 tokens), as minted in our contract constructor. Click Add Tokens : The token has now been added to MetaMask and we can use the MetaMask interface to view the token balance and to transfer the token to others. Transferring an ERC-20 Token with MetaMask \u00b6 Continuing from the previous step, click the Send button in the MetaMask interface: Select a recipient (if you have multiple accounts in MetaMask you can simply select another account), and an amount of tokens to send. Click Next : Note Once again the gas price should be set to zero, but this will change going forward. Click Confirm to send the transaction to the network: After a few moments the transaction will be confirmed by the network. You can see the updated balance your account holds in the MetaMask interface: If you transferred to another MetaMask account you hold then you can follow the aforementioned instructions for adding the token to MetaMask on the other account, and view its balance also. Summary \u00b6 In this tutorial we connected MetaMask to the Aurora Testnet, deployed an ERC-20 token contract using Remix, and transferred that token using MetaMask. The only difference to doing this on the original Ethereum network was setting the RPC endpoint to be Aurora's.","title":"MetaMask"},{"location":"develop/start/metamask.html#getting-started-with-metamask","text":"","title":"Getting Started with MetaMask"},{"location":"develop/start/metamask.html#introduction","text":"MetaMask is a convenient UI for interacting with Ethereum-compatible blockchains (such as Aurora). For the purpose of this guide, we will assume you are already familiar with MetaMask and have it installed. If you need help getting started with MetaMask itself, check out their documentation . In this tutorial we will walk through connecting MetaMask to the Aurora Testnet, deploying a simple ERC-20 contract using Remix , and transferring the new token using MetaMask. Note Screenshots in this tutorial are taken from the MetaMask browser extension version 9.5.5.","title":"Introduction"},{"location":"develop/start/metamask.html#connecting-metamask-to-aurora","text":"In the top-right corner of the MetaMask interface, click the network selection drop-down and then click Custom RPC . Fill in the form with the following information: Network Name: Aurora Testnet New RPC URL: https://testnet.aurora.dev/ Chain ID: 1313161555 Currency Symbol: ETH Note All the Aurora RPC endpoint URLs and chain IDs can be found on our Networks page. Click Save , and you should see Aurora Testnet is now the network selected in MetaMask. To see MetaMask in action, we will connect it to Remix and perform some transactions.","title":"Connecting MetaMask to Aurora"},{"location":"develop/start/metamask.html#deploying-an-erc-20-token-using-remix","text":"In a new tab, open the Remix IDE at remix.ethereum.org . It might take a minute to load, but once it has, create a new file ERC20Token.sol in the workspace panel on the left: Copy and paste the following code into the central editor panel: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/ERC20.sol\" ; contract MyToken is ERC20 { constructor ( string memory name , string memory symbol ) ERC20 ( name , symbol ) { // Mint 100 tokens to msg.sender // Similar to how // 1 dollar = 100 cents // 1 token = 1 * (10 ** decimals) _mint ( msg.sender , 100 * 10 ** uint ( decimals ())); } } This code is a slightly modified (the Solidity compiler and OpenZeppelin versions are newer) version of the example from Solidity by Example . Click the Solidity Compile button on the far left panel (the second icon down); ensure your selected Solidity compiler version is 0.8 (minor versions within 0.8, e.g., 0.8.4 work too), and click Compile ERC20Token.sol . Once the contract is compiled, click the Deploy & run transactions button in the far left panel (the icon below the Solidity compiler). In the ENVIRONMENT drop-down select Injected Web3 . You will see a MetaMask pop-up window asking you to give the Remix IDE permission to access it. Click Next and then Connect to grant access. Back in the Remix interface, click the arrow next to the DEPLOY section of the left panel. Fill in the token details with whatever you like ( MyToken and MT in the example), and click transact . Another MetaMask pop-up will appear asking you to confirm the transaction. Click Confirm . Note You may be surprised to see the gas price set to zero in this transaction. During the early access period Aurora transactions are free, however this will change in the future. Not to worry, even when transaction fees will be non-zero, they'll still be much lower than on the Ethereum 1.0 Mainnet. After a few moments the transaction will be confirmed by the network. You will see a success message in the bottom panel and the contract listed under Deployed Contracts on the left panel. Click the copy button to copy the address of the newly deployed contract. Now that the contract is deployed on the Aurora network, we can interact with it via MetaMask.","title":"Deploying an ERC-20 Token using Remix"},{"location":"develop/start/metamask.html#adding-an-erc-20-token-to-metamask","text":"In the MetaMask interface (with the Aurora Testnet network still selected), click the Add Token button: Paste the token address copied from Remix in the previous step. The remaining token details should fill in automatically as MetaMask finds the contract on-chain. Click Next : On the next screen you see the balance (100 tokens), as minted in our contract constructor. Click Add Tokens : The token has now been added to MetaMask and we can use the MetaMask interface to view the token balance and to transfer the token to others.","title":"Adding an ERC-20 Token to MetaMask"},{"location":"develop/start/metamask.html#transferring-an-erc-20-token-with-metamask","text":"Continuing from the previous step, click the Send button in the MetaMask interface: Select a recipient (if you have multiple accounts in MetaMask you can simply select another account), and an amount of tokens to send. Click Next : Note Once again the gas price should be set to zero, but this will change going forward. Click Confirm to send the transaction to the network: After a few moments the transaction will be confirmed by the network. You can see the updated balance your account holds in the MetaMask interface: If you transferred to another MetaMask account you hold then you can follow the aforementioned instructions for adding the token to MetaMask on the other account, and view its balance also.","title":"Transferring an ERC-20 Token with MetaMask"},{"location":"develop/start/metamask.html#summary","text":"In this tutorial we connected MetaMask to the Aurora Testnet, deployed an ERC-20 token contract using Remix, and transferred that token using MetaMask. The only difference to doing this on the original Ethereum network was setting the RPC endpoint to be Aurora's.","title":"Summary"},{"location":"develop/start/truffle.html","text":"Deploying a Contract Using Truffle \u00b6 Introduction \u00b6 Truffle is a widely used development environment and testing framework for Ethereum smart contracts. In this tutorial, we will show by example how to use Truffle with the Aurora Testnet. This tutorial assumes that you are familiar with Truffle and the non-fungible tokens (NFT) concept. For more details about the non-fungible token standard, please refer to the ERC-721 Non-Fungible Token Standard specification. NFT Example \u00b6 This example is originally forked from the OpenZeppelin examples . However, the code has been changed to fit the use case of this tutorial. The use case is about how to deploy and manage the life cycle of a simple COVID-19 vaccine NFT token \ud83d\udc8a\ud83d\udc8a using Truffle on the Aurora Testnet. The minter address (which is managed by the vaccination program manager) can distribute (mint) the vaccine tickets (NFT tokens \ud83d\udc8a\ud83d\udc8a\ud83d\udc8a) to the people who are part of the vaccination program. When participants receive the tokens \ud83d\udc8a, they can get access to the vaccine by spending the NFT token. This means either burning the NFT token or sending it back to the minter address. If the participant chooses to send it back then the minter can redistribute that token \ud83c\udfab to another participant in the line. Then the new participant will have access to the same vaccine token that has been used by the previous participant. Installing Prerequisites \u00b6 This tutorial assumes that you have Node.js 12+ and Yarn. Please refer to the Yarn installation how-to if you don't yet have the yarn command installed locally. To install the prerequisite packages, clone the examples repository and then run yarn : Install Truffle \u00b6 npm install -g truffle Install dependencies \u00b6 git clone https://github.com/aurora-is-near/aurora-examples.git cd aurora-examples/truffle/erc721-example/ yarn Connecting Truffle to Aurora \u00b6 Export your MNEMONIC as follows: export MNEMONIC = 'YOUR MNEMONIC HERE' Now in truffle-config.js , you will need to change the from address as shown below in the aurora network section: ... aurora : { provider : () => se tu pWalle t ('h tt ps : // testnet .aurora.dev') , net work_id : 0 x 4e454153 , gas : 10000000 , fr om : ' 0 x 6 A 33382 de 9 f 73 B 846878 a 57500 d 055 B 981229 ac 4 ' // CHANGE THIS ADDRESS }, The truffle-config.js configuration will pick up your MNEMONIC environment variable and recover the address that will be used for sending and signing transactions on the Aurora network. Deploying the Contract \u00b6 To deploy the CovidVaccineToken contract, you can run the yarn command as follows: yarn deploy:aurora .... _deploy_contracts.js ===================== Deploying 'CovidVaccineToken' ----------------------------- > transaction hash: 0x282012c791d65d0ce2fd1fd9fcc41179dba5bd06c3b02e31e53dbe9cc8af62c1 > Blocks: 7 Seconds: 5 > contract address: 0x3635D999d8CdA2fAf304b390fb26a9c2f364dFbd > block number: 49151611 > block timestamp: 1622034185 > account: 0x6A33382de9f73B846878a57500d055B981229ac4 > balance: 0 > gas used: 2576274 ( 0x274f92 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .05152548 ETH .... Playing with the Truffle Console \u00b6 Now you can test the flow as mentioned in the NFT Example section: Mint tokens \u00b6 The minter mints and transfers NFT tokens for the vaccine program participant. In this example, the new participant address is accounts[1] and the minter address is accounts[0] . Please make sure that you are using the same deployer address as a minter address, otherwise the mint transaction will revert. % truffle console --network aurora truffle ( aurora ) > const cvt = await CovidVaccineToken.deployed () truffle ( aurora ) > const minter = accounts [ 0 ] truffle ( aurora ) > const participant = accounts [ 1 ] truffle ( aurora ) > await cvt.minter () == minter true truffle ( aurora ) > await cvt.mint ( participant, { from: minter }) You should notice that none of the participants are allowed to transfer their NFT tokens to anyone except back to the minter. So let's try to use any participant address to validate this. To do that, change the value of from to accounts[1] , so that the sender will be the first participant (e.g., the participant address 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe ). In the Truffle console: truffle ( aurora ) > await cvt.safeTransferFrom ( participant, accounts [ 2 ] , 1 , { from: participant }) Uncaught Error: execution reverted: ... reason: 'Invalid Transfer' , hijackedStack: 'Error: execution reverted:\\n' This is exactly the same error message we have in our NFT contract in safeTransferFrom : function safeTransferFrom ( address from , address to , uint256 tokenId ) public virtual override { require ( minter == msg.sender || to == minter , 'Invalid Transfer' ); safeTransferFrom ( from , to , tokenId , \"\" ); } Transfer tokens \u00b6 Participants can transfer the token to the minter after receiving the vaccine. As shown below, a participant can only send the NFT token if the receiver for this token is the minter ( accounts[0] ). truffle ( aurora ) > const tokenID = 1 truffle ( aurora ) > await cvt.ownerOf ( tokenID ) == participant true truffle ( aurora ) > await cvt.safeTransferFrom ( participant, minter, tokenID, { from: participant }) truffle ( aurora ) > await cvt.ownerOf ( tokenID ) == minter true Burn tokens \u00b6 This is an alternative scenario for the NFT token lifecycle. Instead of transferring the token back to the minter, the participant can decide to burn the NFT token by calling the burn function: truffle ( aurora ) > await cvt.burn ( 1 , { from: participant }) // 1 is the tokenID Redistribute tokens \u00b6 Finally, the minter can send the same token (if not burnt) to a new participant in the line: truffle ( aurora ) > await cvt.safeTransferFrom ( minter, accounts [ 2 ] , 1 , { from: minter }) truffle ( aurora ) > await cvt.ownerOf ( 1 ) == accounts [ 2 ] true Summary \u00b6 In this simple tutorial, we deployed an NFT contract to the Aurora Testnet using Truffle and interacted with the contract's functions.","title":"Truffle"},{"location":"develop/start/truffle.html#deploying-a-contract-using-truffle","text":"","title":"Deploying a Contract Using Truffle"},{"location":"develop/start/truffle.html#introduction","text":"Truffle is a widely used development environment and testing framework for Ethereum smart contracts. In this tutorial, we will show by example how to use Truffle with the Aurora Testnet. This tutorial assumes that you are familiar with Truffle and the non-fungible tokens (NFT) concept. For more details about the non-fungible token standard, please refer to the ERC-721 Non-Fungible Token Standard specification.","title":"Introduction"},{"location":"develop/start/truffle.html#nft-example","text":"This example is originally forked from the OpenZeppelin examples . However, the code has been changed to fit the use case of this tutorial. The use case is about how to deploy and manage the life cycle of a simple COVID-19 vaccine NFT token \ud83d\udc8a\ud83d\udc8a using Truffle on the Aurora Testnet. The minter address (which is managed by the vaccination program manager) can distribute (mint) the vaccine tickets (NFT tokens \ud83d\udc8a\ud83d\udc8a\ud83d\udc8a) to the people who are part of the vaccination program. When participants receive the tokens \ud83d\udc8a, they can get access to the vaccine by spending the NFT token. This means either burning the NFT token or sending it back to the minter address. If the participant chooses to send it back then the minter can redistribute that token \ud83c\udfab to another participant in the line. Then the new participant will have access to the same vaccine token that has been used by the previous participant.","title":"NFT Example"},{"location":"develop/start/truffle.html#installing-prerequisites","text":"This tutorial assumes that you have Node.js 12+ and Yarn. Please refer to the Yarn installation how-to if you don't yet have the yarn command installed locally. To install the prerequisite packages, clone the examples repository and then run yarn :","title":"Installing Prerequisites"},{"location":"develop/start/truffle.html#install-truffle","text":"npm install -g truffle","title":"Install Truffle"},{"location":"develop/start/truffle.html#install-dependencies","text":"git clone https://github.com/aurora-is-near/aurora-examples.git cd aurora-examples/truffle/erc721-example/ yarn","title":"Install dependencies"},{"location":"develop/start/truffle.html#connecting-truffle-to-aurora","text":"Export your MNEMONIC as follows: export MNEMONIC = 'YOUR MNEMONIC HERE' Now in truffle-config.js , you will need to change the from address as shown below in the aurora network section: ... aurora : { provider : () => se tu pWalle t ('h tt ps : // testnet .aurora.dev') , net work_id : 0 x 4e454153 , gas : 10000000 , fr om : ' 0 x 6 A 33382 de 9 f 73 B 846878 a 57500 d 055 B 981229 ac 4 ' // CHANGE THIS ADDRESS }, The truffle-config.js configuration will pick up your MNEMONIC environment variable and recover the address that will be used for sending and signing transactions on the Aurora network.","title":"Connecting Truffle to Aurora"},{"location":"develop/start/truffle.html#deploying-the-contract","text":"To deploy the CovidVaccineToken contract, you can run the yarn command as follows: yarn deploy:aurora .... _deploy_contracts.js ===================== Deploying 'CovidVaccineToken' ----------------------------- > transaction hash: 0x282012c791d65d0ce2fd1fd9fcc41179dba5bd06c3b02e31e53dbe9cc8af62c1 > Blocks: 7 Seconds: 5 > contract address: 0x3635D999d8CdA2fAf304b390fb26a9c2f364dFbd > block number: 49151611 > block timestamp: 1622034185 > account: 0x6A33382de9f73B846878a57500d055B981229ac4 > balance: 0 > gas used: 2576274 ( 0x274f92 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .05152548 ETH ....","title":"Deploying the Contract"},{"location":"develop/start/truffle.html#playing-with-the-truffle-console","text":"Now you can test the flow as mentioned in the NFT Example section:","title":"Playing with the Truffle Console"},{"location":"develop/start/truffle.html#mint-tokens","text":"The minter mints and transfers NFT tokens for the vaccine program participant. In this example, the new participant address is accounts[1] and the minter address is accounts[0] . Please make sure that you are using the same deployer address as a minter address, otherwise the mint transaction will revert. % truffle console --network aurora truffle ( aurora ) > const cvt = await CovidVaccineToken.deployed () truffle ( aurora ) > const minter = accounts [ 0 ] truffle ( aurora ) > const participant = accounts [ 1 ] truffle ( aurora ) > await cvt.minter () == minter true truffle ( aurora ) > await cvt.mint ( participant, { from: minter }) You should notice that none of the participants are allowed to transfer their NFT tokens to anyone except back to the minter. So let's try to use any participant address to validate this. To do that, change the value of from to accounts[1] , so that the sender will be the first participant (e.g., the participant address 0x2531a4D108619a20ACeE88C4354a50e9aC48ecfe ). In the Truffle console: truffle ( aurora ) > await cvt.safeTransferFrom ( participant, accounts [ 2 ] , 1 , { from: participant }) Uncaught Error: execution reverted: ... reason: 'Invalid Transfer' , hijackedStack: 'Error: execution reverted:\\n' This is exactly the same error message we have in our NFT contract in safeTransferFrom : function safeTransferFrom ( address from , address to , uint256 tokenId ) public virtual override { require ( minter == msg.sender || to == minter , 'Invalid Transfer' ); safeTransferFrom ( from , to , tokenId , \"\" ); }","title":"Mint tokens"},{"location":"develop/start/truffle.html#transfer-tokens","text":"Participants can transfer the token to the minter after receiving the vaccine. As shown below, a participant can only send the NFT token if the receiver for this token is the minter ( accounts[0] ). truffle ( aurora ) > const tokenID = 1 truffle ( aurora ) > await cvt.ownerOf ( tokenID ) == participant true truffle ( aurora ) > await cvt.safeTransferFrom ( participant, minter, tokenID, { from: participant }) truffle ( aurora ) > await cvt.ownerOf ( tokenID ) == minter true","title":"Transfer tokens"},{"location":"develop/start/truffle.html#burn-tokens","text":"This is an alternative scenario for the NFT token lifecycle. Instead of transferring the token back to the minter, the participant can decide to burn the NFT token by calling the burn function: truffle ( aurora ) > await cvt.burn ( 1 , { from: participant }) // 1 is the tokenID","title":"Burn tokens"},{"location":"develop/start/truffle.html#redistribute-tokens","text":"Finally, the minter can send the same token (if not burnt) to a new participant in the line: truffle ( aurora ) > await cvt.safeTransferFrom ( minter, accounts [ 2 ] , 1 , { from: minter }) truffle ( aurora ) > await cvt.ownerOf ( 1 ) == accounts [ 2 ] true","title":"Redistribute tokens"},{"location":"develop/start/truffle.html#summary","text":"In this simple tutorial, we deployed an NFT contract to the Aurora Testnet using Truffle and interacted with the contract's functions.","title":"Summary"},{"location":"integrate/index.html","text":"","title":"Index"},{"location":"learn/index.html","text":"Tutorials \u00b6","title":"Aurora: Tutorials"},{"location":"learn/index.html#tutorials","text":"","title":"Tutorials"},{"location":"learn/bridge/index.html","text":"Bridging from/to Ethereum \u00b6 Bridging from Ethereum \u00b6 Bridging to Ethereum \u00b6","title":"Aurora: Bridging from/to Ethereum"},{"location":"learn/bridge/index.html#bridging-fromto-ethereum","text":"","title":"Bridging from/to Ethereum"},{"location":"learn/bridge/index.html#bridging-from-ethereum","text":"","title":"Bridging from Ethereum"},{"location":"learn/bridge/index.html#bridging-to-ethereum","text":"","title":"Bridging to Ethereum"},{"location":"learn/bridge/erc-20.html","text":"Bridging ERC-20 Tokens \u00b6","title":"Aurora: Bridging ERC-20 Tokens"},{"location":"learn/bridge/erc-20.html#bridging-erc-20-tokens","text":"","title":"Bridging ERC-20 Tokens"},{"location":"learn/bridge/eth.html","text":"Bridging ETH Balances \u00b6 Note Bridging ETH is currently only enabled for Ropsten Testnet to Aurora Testnet. Before you begin, ensure you have the Ropsten Testnet selected in MetaMask (see instructions here ). If you need Ropsten ETH to transfer, you can get some from faucets such as MetaMask's or DeFi Karen's . For this tutorial, you should have (at least) 2 Ropsten ETH already on your account. Go to the Bridge UI . If you have not yet connected MetaMask to the UI, follow the instructions here . Enter the amount of ETH to transfer in the Amount box (in this example we send 1 ETH) then click Continue . Click Confirm , then confirm the transaction in the MetaMask pop-up. After a minute or two the transaction on the Ropsten network will confirm in MetaMask. At this point the ETH is locked on the Ropsten side in a contract, and it has emitted a Deposit event. The Aurora relayers watch for such events and automatically forward a transaction to the NEAR network (where Aurora runs). This takes some time because we must wait for multiple block confirmations on Ropsten to be sure it will not revert. While this is happening you will see an intermediate message in the Bridge UI. After the transaction is complete (several minutes later) it will appear as \"Completed\" in the UI. You can now see your balance in MetaMask by switching to the Aurora Testnet.","title":"ETH Balances"},{"location":"learn/bridge/eth.html#bridging-eth-balances","text":"Note Bridging ETH is currently only enabled for Ropsten Testnet to Aurora Testnet. Before you begin, ensure you have the Ropsten Testnet selected in MetaMask (see instructions here ). If you need Ropsten ETH to transfer, you can get some from faucets such as MetaMask's or DeFi Karen's . For this tutorial, you should have (at least) 2 Ropsten ETH already on your account. Go to the Bridge UI . If you have not yet connected MetaMask to the UI, follow the instructions here . Enter the amount of ETH to transfer in the Amount box (in this example we send 1 ETH) then click Continue . Click Confirm , then confirm the transaction in the MetaMask pop-up. After a minute or two the transaction on the Ropsten network will confirm in MetaMask. At this point the ETH is locked on the Ropsten side in a contract, and it has emitted a Deposit event. The Aurora relayers watch for such events and automatically forward a transaction to the NEAR network (where Aurora runs). This takes some time because we must wait for multiple block confirmations on Ropsten to be sure it will not revert. While this is happening you will see an intermediate message in the Bridge UI. After the transaction is complete (several minutes later) it will appear as \"Completed\" in the UI. You can now see your balance in MetaMask by switching to the Aurora Testnet.","title":"Bridging ETH Balances"},{"location":"learn/connect/index.html","text":"Connecting a Wallet \u00b6","title":"Aurora: Connecting a Wallet"},{"location":"learn/connect/index.html#connecting-a-wallet","text":"","title":"Connecting a Wallet"},{"location":"learn/connect/metamask.html","text":"Connecting with MetaMask \u00b6 The easiest way to connect Aurora to MetaMask is to use the Bridge UI. If you want to manually add Aurora as a custom RPC in MetaMask, then check out the tutorial under the Develop tab . If that last sentence didn't make sense to you, that's good, you're in the right place. We assume you already have the MetaMask browser extension installed. If you need help getting set up with MetaMask in the first place, please see their website . Connecting to the Bridge front-end \u00b6 Aurora is still a work in progress, so our bridge is currently only working with the Ropsten Testnet (an Ethereum test network). For the remainder of the tutorial we will focus on adding the Aurora Testnet to MetaMask. Before we begin, ensure that you have the Ropsten network selected in MetaMask. In the MetaMask UI click the network selection drop-down in the top right, then click Ropsten test network . Go to the Bridge webpage and click the Connect wallet button in the top right. In the pop-up MetaMask window click Next then Connect . If you see Unsupported in the top right corner of the Bridge page, make sure you have the Ropsten network selected in MetaMask (per the previous steps), otherwise you should now see Ropsten Testnet in the top right corner. To connect MetaMask with Aurora, click the <> arrows between Ropsten Testnet and Aurora Testnet . In the MetaMask pop-up window click Approve then Switch network . That's it! If you look in the MetaMask UI you will see that you are now connected to the Aurora Testnet network. Next steps \u00b6 While you are on the bridge page, why not transfer some ETH from your account on Ropsten to your account on Aurora ? Or if you want to try deploing a smart contract, check out the tutorial using Remix with MetaMask .","title":"MetaMask"},{"location":"learn/connect/metamask.html#connecting-with-metamask","text":"The easiest way to connect Aurora to MetaMask is to use the Bridge UI. If you want to manually add Aurora as a custom RPC in MetaMask, then check out the tutorial under the Develop tab . If that last sentence didn't make sense to you, that's good, you're in the right place. We assume you already have the MetaMask browser extension installed. If you need help getting set up with MetaMask in the first place, please see their website .","title":"Connecting with MetaMask"},{"location":"learn/connect/metamask.html#connecting-to-the-bridge-front-end","text":"Aurora is still a work in progress, so our bridge is currently only working with the Ropsten Testnet (an Ethereum test network). For the remainder of the tutorial we will focus on adding the Aurora Testnet to MetaMask. Before we begin, ensure that you have the Ropsten network selected in MetaMask. In the MetaMask UI click the network selection drop-down in the top right, then click Ropsten test network . Go to the Bridge webpage and click the Connect wallet button in the top right. In the pop-up MetaMask window click Next then Connect . If you see Unsupported in the top right corner of the Bridge page, make sure you have the Ropsten network selected in MetaMask (per the previous steps), otherwise you should now see Ropsten Testnet in the top right corner. To connect MetaMask with Aurora, click the <> arrows between Ropsten Testnet and Aurora Testnet . In the MetaMask pop-up window click Approve then Switch network . That's it! If you look in the MetaMask UI you will see that you are now connected to the Aurora Testnet network.","title":"Connecting to the Bridge front-end"},{"location":"learn/connect/metamask.html#next-steps","text":"While you are on the bridge page, why not transfer some ETH from your account on Ropsten to your account on Aurora ? Or if you want to try deploing a smart contract, check out the tutorial using Remix with MetaMask .","title":"Next steps"},{"location":"learn/connect/walletconnect.html","text":"Connecting with WalletConnect \u00b6","title":"Aurora: Connecting with WalletConnect"},{"location":"learn/connect/walletconnect.html#connecting-with-walletconnect","text":"","title":"Connecting with WalletConnect"},{"location":"learn/deploy/index.html","text":"Deploying a Contract \u00b6","title":"Aurora: Deploying a Contract"},{"location":"learn/deploy/index.html#deploying-a-contract","text":"","title":"Deploying a Contract"},{"location":"learn/deploy/hardhat.html","text":"Deploying a Contract Using Hardhat \u00b6","title":"Aurora: Deploying a Contract Using Hardhat"},{"location":"learn/deploy/hardhat.html#deploying-a-contract-using-hardhat","text":"","title":"Deploying a Contract Using Hardhat"},{"location":"learn/deploy/remix.html","text":"Deploying a Contract Using Remix \u00b6","title":"Aurora: Deploying a Contract Using Remix"},{"location":"learn/deploy/remix.html#deploying-a-contract-using-remix","text":"","title":"Deploying a Contract Using Remix"},{"location":"learn/deploy/truffle.html","text":"Deploying a Contract Using Truffle \u00b6","title":"Aurora: Deploying a Contract Using Truffle"},{"location":"learn/deploy/truffle.html#deploying-a-contract-using-truffle","text":"","title":"Deploying a Contract Using Truffle"},{"location":"learn/interact/index.html","text":"Interacting with Contracts \u00b6","title":"Aurora: Interacting with Contracts"},{"location":"learn/interact/index.html#interacting-with-contracts","text":"","title":"Interacting with Contracts"},{"location":"learn/interact/remix.html","text":"Interacting with Contracts Using Remix \u00b6","title":"Aurora: Interacting with Contracts Using Remix"},{"location":"learn/interact/remix.html#interacting-with-contracts-using-remix","text":"","title":"Interacting with Contracts Using Remix"}]}